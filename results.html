<!DOCTYPE html>
<html>
    <head></head>
    <body>
        <div id="header">
            <p id="tokens"></p>
            <p id="passed"></p>
            <p id="failed"></p>
            <p id="reasons"></p>
        </div>
        <div id="container">
            <div id="selector"></div>
            <div id="viewer"></div>
        </div>
    </body>
    <script>
        window.location.hash = ""

        const results = [{"iterations": 2, "passed": false, "test": "accumulate", "response": "The coder failed the test because they didn't pass the function as a parameter correctly in the test cases. The test cases are trying to call the function directly instead of passing it as an argument to the accumulate function.\n\nreason: logic\n", "reason": "logic", "tokens": 4473, "instructions": "instructions.md\n# Instructions\n\nImplement the `accumulate` operation, which, given a collection and an\noperation to perform on each element of the collection, returns a new\ncollection containing the result of applying that operation to each element of\nthe input collection.\n\nGiven the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the operation:\n\n- square a number (`x => x * x`)\n\nYour code should be able to produce the collection of squares:\n\n- 1, 4, 9, 16, 25\n\nCheck out the test suite to see the expected function signature.\n\n## Restrictions\n\nKeep your hands off that collect/map/fmap/whatchamacallit functionality\nprovided by your standard library!\nSolve this one yourself using other basic tools instead.\n\n", "code": "accumulate.clj\n(ns accumulate)\n\n(defn accumulate [coll f]\n  (loop [input coll\n         output []]\n    (if (empty? input)\n      output\n      (recur (rest input) (conj output (f (first input)))))))\n", "test-output": "test_output.txt\n\nlein test accumulate-test\n\nlein test :only accumulate-test/empty-accumulation\n\nERROR in (empty-accumulation) (RT.java:553)\nexpected: (= [] (accumulate/accumulate square []))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: accumulate_test$square\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$empty_QMARK_.invokeStatic (core.clj:6206)\n    clojure.core$empty_QMARK_.invoke (core.clj:6206)\n    accumulate$accumulate.invokeStatic (accumulate.clj:6)\n    accumulate$accumulate.invoke (accumulate.clj:3)\n    accumulate_test$fn__443.invokeStatic (accumulate_test.clj:10)\n    accumulate_test/fn (accumulate_test.clj:9)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357.invoke (form-init16158904610527034764.clj:1)\n    user$eval224.invokeStatic (form-init16158904610527034764.clj:1)\n    user$eval224.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only accumulate-test/accumulate-squares\n\nERROR in (accumulate-squares) (RT.java:553)\nexpected: (= [1 4 9] (accumulate/accumulate square [1 2 3]))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: accumulate_test$square\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$empty_QMARK_.invokeStatic (core.clj:6206)\n    clojure.core$empty_QMARK_.invoke (core.clj:6206)\n    accumulate$accumulate.invokeStatic (accumulate.clj:6)\n    accumulate$accumulate.invoke (accumulate.clj:3)\n    accumulate_test$fn__448.invokeStatic (accumulate_test.clj:13)\n    accumulate_test/fn (accumulate_test.clj:12)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357.invoke (form-init16158904610527034764.clj:1)\n    user$eval224.invokeStatic (form-init16158904610527034764.clj:1)\n    user$eval224.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only accumulate-test/accumulate-upcases\n\nERROR in (accumulate-upcases) (RT.java:553)\nexpected: (= [\"HELLO\" \"WORLD\"] (->> [\"hello\" \"world\"] (accumulate/accumulate clojure.string/upper-case) (map to-s)))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: clojure.string$upper_case\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$empty_QMARK_.invokeStatic (core.clj:6206)\n    clojure.core$empty_QMARK_.invoke (core.clj:6206)\n    accumulate$accumulate.invokeStatic (accumulate.clj:6)\n    accumulate$accumulate.invoke (accumulate.clj:3)\n    accumulate_test$fn__453.invokeStatic (accumulate_test.clj:18)\n    accumulate_test/fn (accumulate_test.clj:15)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357.invoke (form-init16158904610527034764.clj:1)\n    user$eval224.invokeStatic (form-init16158904610527034764.clj:1)\n    user$eval224.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only accumulate-test/accumulate-recursively\n\nERROR in (accumulate-recursively) (RT.java:553)\nexpected: (= [[\"a1\" \"a2\" \"a3\"] [\"b1\" \"b2\" \"b3\"] [\"c1\" \"c2\" \"c3\"]] (-> (fn* [p1__463#] (accumulate/accumulate (fn [n] (str p1__463# n)) [1 2 3])) (accumulate/accumulate \"abc\")))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: accumulate_test$fn__464$fn__465\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$empty_QMARK_.invokeStatic (core.clj:6206)\n    clojure.core$empty_QMARK_.invoke (core.clj:6206)\n    accumulate$accumulate.invokeStatic (accumulate.clj:6)\n    accumulate$accumulate.invoke (accumulate.clj:3)\n    accumulate_test$fn__464.invokeStatic (accumulate_test.clj:30)\n    accumulate_test/fn (accumulate_test.clj:27)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357.invoke (form-init16158904610527034764.clj:1)\n    user$eval224.invokeStatic (form-init16158904610527034764.clj:1)\n    user$eval224.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only accumulate-test/accumulate-reversed-strings\n\nERROR in (accumulate-reversed-strings) (RT.java:553)\nexpected: (= [\"eht\" \"kciuq\" \"nworb\" \"xof\" \"cte\"] (->> [\"the\" \"quick\" \"brown\" \"fox\" \"etc\"] (accumulate/accumulate reverse) (map to-s)))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: clojure.core$reverse\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$empty_QMARK_.invokeStatic (core.clj:6206)\n    clojure.core$empty_QMARK_.invoke (core.clj:6206)\n    accumulate$accumulate.invokeStatic (accumulate.clj:6)\n    accumulate$accumulate.invoke (accumulate.clj:3)\n    accumulate_test$fn__458.invokeStatic (accumulate_test.clj:24)\n    accumulate_test/fn (accumulate_test.clj:21)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16158904610527034764.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16158904610527034764.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16158904610527034764.clj:1)\n    user$eval224$fn__357.invoke (form-init16158904610527034764.clj:1)\n    user$eval224.invokeStatic (form-init16158904610527034764.clj:1)\n    user$eval224.invoke (form-init16158904610527034764.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 5 tests containing 5 assertions.\n0 failures, 5 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "acronym", "response": "The coder attempted to solve the problem by splitting the phrase, converting it to uppercase, and extracting the first character of each word. However, the test suite timed out when running their solution.\n\nreason: logic\n", "reason": "logic", "tokens": 3482, "instructions": "instructions.md\n# Instructions\n\nConvert a phrase to its acronym.\n\nTechies love their TLA (Three Letter Acronyms)!\n\nHelp generate some jargon by writing a program that converts a long name\nlike Portable Network Graphics to its acronym (PNG).\n\n", "code": "acronym.clj\n(ns acronym)\n\n(defn acronym\n  \"Converts phrase to its acronym.\"\n  [phrase]\n  (->> (clojure.string/split phrase #\"[ -]\")\n       (mapcat clojure.string/split-lines)\n       (map clojure.string/upper-case)\n       (map first)\n       (apply str)))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "all-your-base", "response": "The coder had a duplicated line in their code, causing it to not be compiled/interpreted correctly. The duplicated line is an extra if expression in the `convert` function.\n\nreason: duplication\n", "reason": "duplication", "tokens": 4446, "instructions": "instructions.md\n# Instructions\n\nConvert a number, represented as a sequence of digits in one base, to any other base.\n\nImplement general base conversion. Given a number in base **a**,\nrepresented as a sequence of digits, convert it to base **b**.\n\n## Note\n\n- Try to implement the conversion yourself.\n  Do not use something else to perform the conversion for you.\n- Your solution should take base **a**, a sequence of digits, and base **b**, in that order.\n\n## About [Positional Notation](https://en.wikipedia.org/wiki/Positional_notation)\n\nIn positional notation, a number in base **b** can be understood as a linear\ncombination of powers of **b**.\n\nThe number 42, *in base 10*, means:\n\n(4 * 10^1) + (2 * 10^0)\n\nThe number 101010, *in base 2*, means:\n\n(1 * 2^5) + (0 * 2^4) + (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (0 * 2^0)\n\nThe number 1120, *in base 3*, means:\n\n(1 * 3^3) + (1 * 3^2) + (2 * 3^1) + (0 * 3^0)\n\nI think you got the idea!\n\n*Yes. Those three numbers above are exactly the same. Congratulations!*\n\n", "code": "all_your_base.clj\n(ns all-your-base)\n\n(defn validate-input [base-a digits base-b]\n  (when (or (< base-a 2) (< base-b 2))\n    (throw (IllegalArgumentException. \"Bases must be greater than 1\")))\n  (when (some #(or (< % 0) (>= % base-a)) digits)\n    (throw (IllegalArgumentException. \"Digits must be within the base range\")))\n  (when (and (seq digits) (= (first digits) 0))\n    (throw (IllegalArgumentException. \"Digits cannot have leading zeros\"))))\n(defn convert [base-a digits base-b]\n  (validate-input base-a digits base-b)\n  (let [number-in-base-10 (reduce #(+ (* %1 base-a) %2) 0 digits)]\n    (loop [remaining number-in-base-10 result []]\n      (if (zero? remaining)\n        (if (empty? result)\n          [0]\n          result)\n        (recur (quot remaining base-b) (cons (mod remaining base-b) result))))))\n      (if (zero? remaining)\n        (if (empty? result)\n          [0]\n          result)\n        (recur (quot remaining base-b) (cons (mod remaining base-b) result))))))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": true, "test": "allergies", "tokens": 5292, "instructions": "instructions.md\n# Instructions\n\nGiven a person's allergy score, determine whether or not they're allergic to a given item, and their full list of allergies.\n\nAn allergy test produces a single numeric score which contains the\ninformation about all the allergies the person has (that they were\ntested for).\n\nThe list of items (and their value) that were tested are:\n\n* eggs (1)\n* peanuts (2)\n* shellfish (4)\n* strawberries (8)\n* tomatoes (16)\n* chocolate (32)\n* pollen (64)\n* cats (128)\n\nSo if Tom is allergic to peanuts and chocolate, he gets a score of 34.\n\nNow, given just that score of 34, your program should be able to say:\n\n- Whether Tom is allergic to any one of those allergens listed above.\n- All the allergens Tom is allergic to.\n\nNote: a given score may include allergens **not** listed above (i.e.\nallergens that score 256, 512, 1024, etc.).  Your program should\nignore those components of the score.  For example, if the allergy\nscore is 257, your program should only report the eggs (1) allergy.\n\n", "code": "allergies.clj\n(ns allergies)\n\n(defn allergies [score]\n  (let [allergens {:eggs 1, :peanuts 2, :shellfish 4, :strawberries 8, :tomatoes 16, :chocolate 32, :pollen 64, :cats 128}]\n    (mapv first (filter (fn [[k v]] (not= (bit-and score v) 0)) allergens))))\n\n(defn allergic-to? [score allergen]\n  (let [allergens {:eggs 1, :peanuts 2, :shellfish 4, :strawberries 8, :tomatoes 16, :chocolate 32, :pollen 64, :cats 128}]\n    (not= (bit-and score (get allergens allergen)) 0)))\n", "test-output": "test_output.txt\n\nlein test allergies-test\n\nRan 14 tests containing 14 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "anagram", "response": "The coder failed the test due to a syntax error in the code. The issue is with the namespace declaration and the required library.\n\nThe correct syntax for requiring a library in Clojure is `(:require [library :as alias])`. In the provided code, the coder missed the square brackets around the library and alias.\n\nThe correct namespace declaration should be:\n```clojure\n(ns anagram\n  (:require [clojure.string :as string]))\n```\n\nreason: syntax\n", "reason": "syntax", "tokens": 3795, "instructions": "instructions.md\n# Instructions\n\nAn anagram is a rearrangement of letters to form a new word.\nGiven a word and a list of candidates, select the sublist of anagrams of the given word.\n\nGiven `\"listen\"` and a list of candidates like `\"enlists\" \"google\"\n\"inlets\" \"banana\"` the program should return a list containing\n`\"inlets\"`.\n\n", "code": "anagram.clj\n(ns anagram)\n(:require [clojure.string :as string])\n\n(defn anagrams-for [word prospect-list]\n  (let [sorted-word (sort (string/lower-case word))]\n    (filter (fn [candidate]\n              (let [lower-candidate (string/lower-case candidate)\n                    sorted-candidate (sort lower-candidate)]\n                (and (= sorted-word sorted-candidate)\n                     (not= lower-candidate (string/lower-case word)))))\n            prospect-list)))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (anagram.clj:2:1).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$VectorExpr.parse(Compiler.java:3260)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6791)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3881)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.eval(Compiler.java:7173)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat anagram_test$eval422$loading__6706__auto____423.invoke(anagram_test.clj:1)\n\tat anagram_test$eval422.invokeStatic(anagram_test.clj:1)\n\tat anagram_test$eval422.invoke(anagram_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init16398526410128657986.clj:1)\n\tat user$eval224.invoke(form-init16398526410128657986.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.ClassNotFoundException: clojure.string\n\tat java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:476)\n\tat clojure.lang.DynamicClassLoader.findClass(DynamicClassLoader.java:69)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:594)\n\tat clojure.lang.DynamicClassLoader.loadClass(DynamicClassLoader.java:77)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:527)\n\tat java.base/java.lang.Class.forName0(Native Method)\n\tat java.base/java.lang.Class.forName(Class.java:398)\n\tat clojure.lang.RT.classForName(RT.java:2207)\n\tat clojure.lang.RT.classForName(RT.java:2216)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7394)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 84 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "armstrong-numbers", "response": "The coder implemented the function to check if a number is an Armstrong number, but the test suite timed out. This could be due to an inefficient implementation or an issue with the test suite itself.\n\nreason: other\n", "reason": "other", "tokens": 4208, "instructions": "instructions.md\n# Instructions\n\nAn [Armstrong number][armstrong-number] is a number that is the sum of its own digits each raised to the power of the number of digits.\n\nFor example:\n\n- 9 is an Armstrong number, because `9 = 9^1 = 9`\n- 10 is *not* an Armstrong number, because `10 != 1^2 + 0^2 = 1`\n- 153 is an Armstrong number, because: `153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153`\n- 154 is *not* an Armstrong number, because: `154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190`\n\nWrite some code to determine whether a number is an Armstrong number.\n\n[armstrong-number]: https://en.wikipedia.org/wiki/Narcissistic_number\n\n", "code": "armstrong_numbers.clj\n(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [digits (seq (str num))\n        num-digits (count digits)\n        sum (reduce + (map #(Math/pow (BigInteger/valueOf (Character/digit % 10)) num-digits) digits))]\n    (.equals (BigInteger/valueOf num) sum)))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "atbash-cipher", "response": "The coder implemented the atbash cipher encoding and decoding functions, but the test suite timed out. It seems that there might be an issue with the logic or an infinite loop in the code, causing the test suite to not complete.\n\nreason: logic\n", "reason": "logic", "tokens": 5210, "instructions": "instructions.md\n# Instructions\n\nCreate an implementation of the atbash cipher, an ancient encryption system created in the Middle East.\n\nThe Atbash cipher is a simple substitution cipher that relies on\ntransposing all the letters in the alphabet such that the resulting\nalphabet is backwards. The first letter is replaced with the last\nletter, the second with the second-last, and so on.\n\nAn Atbash cipher for the Latin alphabet would be as follows:\n\n```text\nPlain:  abcdefghijklmnopqrstuvwxyz\nCipher: zyxwvutsrqponmlkjihgfedcba\n```\n\nIt is a very weak cipher because it only has one possible key, and it is\na simple monoalphabetic substitution cipher. However, this may not have\nbeen an issue in the cipher's time.\n\nCiphertext is written out in groups of fixed length, the traditional group size\nbeing 5 letters, and punctuation is excluded. This is to make it harder to guess\nthings based on word boundaries.\n\n## Examples\n\n- Encoding `test` gives `gvhg`\n- Decoding `gvhg` gives `test`\n- Decoding `gsvjf rxpyi ldmul cqfnk hlevi gsvoz abwlt` gives `thequickbrownfoxjumpsoverthelazydog`\n\n", "code": "atbash_cipher.clj\n(ns atbash-cipher)\n\n(defn encode [plaintext]\n  (let [plain \"abcdefghijklmnopqrstuvwxyz\"\n        cipher (apply str (reverse plain))\n        trans (zipmap plain cipher)]\n    (->> plaintext\n         (map #(Character/toLowerCase %))\n         (filter #(Character/isLetterOrDigit %))\n         (map #(get trans % %))\n         (partition 5)\n         (map #(apply str %))\n         (interpose \" \")\n         (apply str))))\n\n(defn decode [ciphertext]\n  (let [plain \"abcdefghijklmnopqrstuvwxyz\"\n        cipher (apply str (reverse plain))\n        trans (zipmap cipher plain)]\n    (->> ciphertext\n         (filter #(Character/isLetterOrDigit %))\n         (map #(% trans))\n         (apply str))))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "bank-account", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 5509, "instructions": "instructions.md\n# Instructions\n\nSimulate a bank account supporting opening/closing, withdrawals, and deposits\nof money. Watch out for concurrent transactions!\n\nA bank account can be accessed in multiple ways. Clients can make\ndeposits and withdrawals using the internet, mobile phones, etc. Shops\ncan charge against the account.\n\nCreate an account that can be accessed from multiple threads/processes\n(terminology depends on your programming language).\n\nIt should be possible to close an account; operations against a closed\naccount must fail.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nHave fun!\n\n", "code": "bank_account.clj\n(ns bank-account)\n(def account-state (atom {:status :closed :balance 0}))\n\n(defn open-account []\n  (reset! account-state {:status :open :balance 0}))\n\n(defn close-account []\n  (swap! account-state assoc :status :closed))\n\n(defn get-balance []\n  (if (= (:status @account-state) :open)\n    (:balance @account-state)\n    (throw (Exception. \"Account is closed\"))))\n\n(defn update-balance [operation amount]\n  (if (= (:status @account-state) :open)\n    (case operation\n      :deposit (swap! account-state update :balance + amount)\n      :withdraw (swap! account-state update :balance - amount))\n    (throw (Exception. \"Account is closed\"))))\n", "test-output": "test_output.txt\nWARNING: pcalls already refers to: #'clojure.core/pcalls in namespace: bank-account-test, being replaced by: #'bank-account-test/pcalls\n\nlein test bank-account-test\n\nlein test :only bank-account-test/check-concurrent-access\n\nERROR in (check-concurrent-access) (FutureTask.java:122)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: java.util.concurrent.ExecutionException: java.lang.IllegalArgumentException: No matching clause: {:status :open, :balance 0}\n at java.util.concurrent.FutureTask.report (FutureTask.java:122)\n    java.util.concurrent.FutureTask.get (FutureTask.java:191)\n    clojure.core$deref_future.invokeStatic (core.clj:2300)\n    clojure.core$future_call$reify__8439.deref (core.clj:6974)\n    clojure.core$deref.invokeStatic (core.clj:2320)\n    clojure.core$deref.invoke (core.clj:2306)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:58)\n    clojure.lang.RT.seq (RT.java:531)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$dorun.invokeStatic (core.clj:3133)\n    clojure.core$doall.invokeStatic (core.clj:3148)\n    clojure.core$doall.invoke (core.clj:3148)\n    bank_account_test$fn__481.invokeStatic (bank_account_test.clj:50)\n    bank_account_test/fn (bank_account_test.clj:46)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\nCaused by: java.lang.IllegalArgumentException: No matching clause: {:status :open, :balance 0}\n at bank_account$update_balance.invokeStatic (bank_account.clj:17)\n    bank_account$update_balance.invoke (bank_account.clj:15)\n    bank_account_test$fn__481$add_10__482.invoke (bank_account_test.clj:49)\n    bank_account_test$pcalls$fn__446.invoke (bank_account_test.clj:11)\n    clojure.core$pmap$fn__8447$fn__8448.invoke (core.clj:7022)\n    clojure.core$binding_conveyor_fn$fn__5739.invoke (core.clj:2030)\n    clojure.lang.AFn.call (AFn.java:18)\n    java.util.concurrent.FutureTask.run (FutureTask.java:264)\n    java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\n    java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\n    java.lang.Thread.run (Thread.java:829)\n\nlein test :only bank-account-test/increment-and-get-balance\n\nERROR in (increment-and-get-balance) (AFn.java:429)\nAdding money to the account works\nexpected: (= 0 (bank-account/get-balance account))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: bank-account/get-balance\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    bank_account_test$fn__454$fn__455.invoke (bank_account_test.clj:27)\n    bank_account_test$fn__454.invokeStatic (bank_account_test.clj:27)\n    bank_account_test/fn (bank_account_test.clj:24)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only bank-account-test/increment-and-get-balance\n\nERROR in (increment-and-get-balance) (bank_account.clj:17)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: java.lang.IllegalArgumentException: No matching clause: {:status :open, :balance 0}\n at bank_account$update_balance.invokeStatic (bank_account.clj:17)\n    bank_account$update_balance.invoke (bank_account.clj:15)\n    bank_account_test$fn__454.invokeStatic (bank_account_test.clj:28)\n    bank_account_test/fn (bank_account_test.clj:24)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only bank-account-test/closed-accounts-are-nil\n\nERROR in (closed-accounts-are-nil) (AFn.java:429)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: bank-account/close-account\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    bank_account_test$fn__476.invokeStatic (bank_account_test.clj:43)\n    bank_account_test/fn (bank_account_test.clj:40)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only bank-account-test/increment-decrement-and-get-balance\n\nERROR in (increment-decrement-and-get-balance) (AFn.java:429)\nTaking money out of the account works\nexpected: (= 0 (bank-account/get-balance account))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: bank-account/get-balance\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    bank_account_test$fn__463$fn__464.invoke (bank_account_test.clj:34)\n    bank_account_test$fn__463.invokeStatic (bank_account_test.clj:34)\n    bank_account_test/fn (bank_account_test.clj:31)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only bank-account-test/increment-decrement-and-get-balance\n\nERROR in (increment-decrement-and-get-balance) (bank_account.clj:17)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: java.lang.IllegalArgumentException: No matching clause: {:status :open, :balance 0}\n at bank_account$update_balance.invokeStatic (bank_account.clj:17)\n    bank_account$update_balance.invoke (bank_account.clj:15)\n    bank_account_test$fn__463.invokeStatic (bank_account_test.clj:35)\n    bank_account_test/fn (bank_account_test.clj:31)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only bank-account-test/initial-account-state\n\nERROR in (initial-account-state) (AFn.java:429)\nAccounts are opened with a balance of 0\nexpected: (= 0 (-> (bank-account/open-account) (bank-account/get-balance)))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: bank-account/get-balance\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    bank_account_test$fn__449.invokeStatic (bank_account_test.clj:22)\n    bank_account_test/fn (bank_account_test.clj:19)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4096936105376513473.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4096936105376513473.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4096936105376513473.clj:1)\n    user$eval224$fn__357.invoke (form-init4096936105376513473.clj:1)\n    user$eval224.invokeStatic (form-init4096936105376513473.clj:1)\n    user$eval224.invoke (form-init4096936105376513473.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 5 tests containing 7 assertions.\n0 failures, 7 errors.\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "beer-song", "tokens": 12802, "instructions": "instructions.md\n# Instructions\n\nRecite the lyrics to that beloved classic, that field-trip favorite: 99 Bottles of Beer on the Wall.\n\nNote that not all verses are identical.\n\n```text\n99 bottles of beer on the wall, 99 bottles of beer.\nTake one down and pass it around, 98 bottles of beer on the wall.\n\n98 bottles of beer on the wall, 98 bottles of beer.\nTake one down and pass it around, 97 bottles of beer on the wall.\n\n97 bottles of beer on the wall, 97 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n\n96 bottles of beer on the wall, 96 bottles of beer.\nTake one down and pass it around, 95 bottles of beer on the wall.\n\n95 bottles of beer on the wall, 95 bottles of beer.\nTake one down and pass it around, 94 bottles of beer on the wall.\n\n94 bottles of beer on the wall, 94 bottles of beer.\nTake one down and pass it around, 93 bottles of beer on the wall.\n\n93 bottles of beer on the wall, 93 bottles of beer.\nTake one down and pass it around, 92 bottles of beer on the wall.\n\n92 bottles of beer on the wall, 92 bottles of beer.\nTake one down and pass it around, 91 bottles of beer on the wall.\n\n91 bottles of beer on the wall, 91 bottles of beer.\nTake one down and pass it around, 90 bottles of beer on the wall.\n\n90 bottles of beer on the wall, 90 bottles of beer.\nTake one down and pass it around, 89 bottles of beer on the wall.\n\n89 bottles of beer on the wall, 89 bottles of beer.\nTake one down and pass it around, 88 bottles of beer on the wall.\n\n88 bottles of beer on the wall, 88 bottles of beer.\nTake one down and pass it around, 87 bottles of beer on the wall.\n\n87 bottles of beer on the wall, 87 bottles of beer.\nTake one down and pass it around, 86 bottles of beer on the wall.\n\n86 bottles of beer on the wall, 86 bottles of beer.\nTake one down and pass it around, 85 bottles of beer on the wall.\n\n85 bottles of beer on the wall, 85 bottles of beer.\nTake one down and pass it around, 84 bottles of beer on the wall.\n\n84 bottles of beer on the wall, 84 bottles of beer.\nTake one down and pass it around, 83 bottles of beer on the wall.\n\n83 bottles of beer on the wall, 83 bottles of beer.\nTake one down and pass it around, 82 bottles of beer on the wall.\n\n82 bottles of beer on the wall, 82 bottles of beer.\nTake one down and pass it around, 81 bottles of beer on the wall.\n\n81 bottles of beer on the wall, 81 bottles of beer.\nTake one down and pass it around, 80 bottles of beer on the wall.\n\n80 bottles of beer on the wall, 80 bottles of beer.\nTake one down and pass it around, 79 bottles of beer on the wall.\n\n79 bottles of beer on the wall, 79 bottles of beer.\nTake one down and pass it around, 78 bottles of beer on the wall.\n\n78 bottles of beer on the wall, 78 bottles of beer.\nTake one down and pass it around, 77 bottles of beer on the wall.\n\n77 bottles of beer on the wall, 77 bottles of beer.\nTake one down and pass it around, 76 bottles of beer on the wall.\n\n76 bottles of beer on the wall, 76 bottles of beer.\nTake one down and pass it around, 75 bottles of beer on the wall.\n\n75 bottles of beer on the wall, 75 bottles of beer.\nTake one down and pass it around, 74 bottles of beer on the wall.\n\n74 bottles of beer on the wall, 74 bottles of beer.\nTake one down and pass it around, 73 bottles of beer on the wall.\n\n73 bottles of beer on the wall, 73 bottles of beer.\nTake one down and pass it around, 72 bottles of beer on the wall.\n\n72 bottles of beer on the wall, 72 bottles of beer.\nTake one down and pass it around, 71 bottles of beer on the wall.\n\n71 bottles of beer on the wall, 71 bottles of beer.\nTake one down and pass it around, 70 bottles of beer on the wall.\n\n70 bottles of beer on the wall, 70 bottles of beer.\nTake one down and pass it around, 69 bottles of beer on the wall.\n\n69 bottles of beer on the wall, 69 bottles of beer.\nTake one down and pass it around, 68 bottles of beer on the wall.\n\n68 bottles of beer on the wall, 68 bottles of beer.\nTake one down and pass it around, 67 bottles of beer on the wall.\n\n67 bottles of beer on the wall, 67 bottles of beer.\nTake one down and pass it around, 66 bottles of beer on the wall.\n\n66 bottles of beer on the wall, 66 bottles of beer.\nTake one down and pass it around, 65 bottles of beer on the wall.\n\n65 bottles of beer on the wall, 65 bottles of beer.\nTake one down and pass it around, 64 bottles of beer on the wall.\n\n64 bottles of beer on the wall, 64 bottles of beer.\nTake one down and pass it around, 63 bottles of beer on the wall.\n\n63 bottles of beer on the wall, 63 bottles of beer.\nTake one down and pass it around, 62 bottles of beer on the wall.\n\n62 bottles of beer on the wall, 62 bottles of beer.\nTake one down and pass it around, 61 bottles of beer on the wall.\n\n61 bottles of beer on the wall, 61 bottles of beer.\nTake one down and pass it around, 60 bottles of beer on the wall.\n\n60 bottles of beer on the wall, 60 bottles of beer.\nTake one down and pass it around, 59 bottles of beer on the wall.\n\n59 bottles of beer on the wall, 59 bottles of beer.\nTake one down and pass it around, 58 bottles of beer on the wall.\n\n58 bottles of beer on the wall, 58 bottles of beer.\nTake one down and pass it around, 57 bottles of beer on the wall.\n\n57 bottles of beer on the wall, 57 bottles of beer.\nTake one down and pass it around, 56 bottles of beer on the wall.\n\n56 bottles of beer on the wall, 56 bottles of beer.\nTake one down and pass it around, 55 bottles of beer on the wall.\n\n55 bottles of beer on the wall, 55 bottles of beer.\nTake one down and pass it around, 54 bottles of beer on the wall.\n\n54 bottles of beer on the wall, 54 bottles of beer.\nTake one down and pass it around, 53 bottles of beer on the wall.\n\n53 bottles of beer on the wall, 53 bottles of beer.\nTake one down and pass it around, 52 bottles of beer on the wall.\n\n52 bottles of beer on the wall, 52 bottles of beer.\nTake one down and pass it around, 51 bottles of beer on the wall.\n\n51 bottles of beer on the wall, 51 bottles of beer.\nTake one down and pass it around, 50 bottles of beer on the wall.\n\n50 bottles of beer on the wall, 50 bottles of beer.\nTake one down and pass it around, 49 bottles of beer on the wall.\n\n49 bottles of beer on the wall, 49 bottles of beer.\nTake one down and pass it around, 48 bottles of beer on the wall.\n\n48 bottles of beer on the wall, 48 bottles of beer.\nTake one down and pass it around, 47 bottles of beer on the wall.\n\n47 bottles of beer on the wall, 47 bottles of beer.\nTake one down and pass it around, 46 bottles of beer on the wall.\n\n46 bottles of beer on the wall, 46 bottles of beer.\nTake one down and pass it around, 45 bottles of beer on the wall.\n\n45 bottles of beer on the wall, 45 bottles of beer.\nTake one down and pass it around, 44 bottles of beer on the wall.\n\n44 bottles of beer on the wall, 44 bottles of beer.\nTake one down and pass it around, 43 bottles of beer on the wall.\n\n43 bottles of beer on the wall, 43 bottles of beer.\nTake one down and pass it around, 42 bottles of beer on the wall.\n\n42 bottles of beer on the wall, 42 bottles of beer.\nTake one down and pass it around, 41 bottles of beer on the wall.\n\n41 bottles of beer on the wall, 41 bottles of beer.\nTake one down and pass it around, 40 bottles of beer on the wall.\n\n40 bottles of beer on the wall, 40 bottles of beer.\nTake one down and pass it around, 39 bottles of beer on the wall.\n\n39 bottles of beer on the wall, 39 bottles of beer.\nTake one down and pass it around, 38 bottles of beer on the wall.\n\n38 bottles of beer on the wall, 38 bottles of beer.\nTake one down and pass it around, 37 bottles of beer on the wall.\n\n37 bottles of beer on the wall, 37 bottles of beer.\nTake one down and pass it around, 36 bottles of beer on the wall.\n\n36 bottles of beer on the wall, 36 bottles of beer.\nTake one down and pass it around, 35 bottles of beer on the wall.\n\n35 bottles of beer on the wall, 35 bottles of beer.\nTake one down and pass it around, 34 bottles of beer on the wall.\n\n34 bottles of beer on the wall, 34 bottles of beer.\nTake one down and pass it around, 33 bottles of beer on the wall.\n\n33 bottles of beer on the wall, 33 bottles of beer.\nTake one down and pass it around, 32 bottles of beer on the wall.\n\n32 bottles of beer on the wall, 32 bottles of beer.\nTake one down and pass it around, 31 bottles of beer on the wall.\n\n31 bottles of beer on the wall, 31 bottles of beer.\nTake one down and pass it around, 30 bottles of beer on the wall.\n\n30 bottles of beer on the wall, 30 bottles of beer.\nTake one down and pass it around, 29 bottles of beer on the wall.\n\n29 bottles of beer on the wall, 29 bottles of beer.\nTake one down and pass it around, 28 bottles of beer on the wall.\n\n28 bottles of beer on the wall, 28 bottles of beer.\nTake one down and pass it around, 27 bottles of beer on the wall.\n\n27 bottles of beer on the wall, 27 bottles of beer.\nTake one down and pass it around, 26 bottles of beer on the wall.\n\n26 bottles of beer on the wall, 26 bottles of beer.\nTake one down and pass it around, 25 bottles of beer on the wall.\n\n25 bottles of beer on the wall, 25 bottles of beer.\nTake one down and pass it around, 24 bottles of beer on the wall.\n\n24 bottles of beer on the wall, 24 bottles of beer.\nTake one down and pass it around, 23 bottles of beer on the wall.\n\n23 bottles of beer on the wall, 23 bottles of beer.\nTake one down and pass it around, 22 bottles of beer on the wall.\n\n22 bottles of beer on the wall, 22 bottles of beer.\nTake one down and pass it around, 21 bottles of beer on the wall.\n\n21 bottles of beer on the wall, 21 bottles of beer.\nTake one down and pass it around, 20 bottles of beer on the wall.\n\n20 bottles of beer on the wall, 20 bottles of beer.\nTake one down and pass it around, 19 bottles of beer on the wall.\n\n19 bottles of beer on the wall, 19 bottles of beer.\nTake one down and pass it around, 18 bottles of beer on the wall.\n\n18 bottles of beer on the wall, 18 bottles of beer.\nTake one down and pass it around, 17 bottles of beer on the wall.\n\n17 bottles of beer on the wall, 17 bottles of beer.\nTake one down and pass it around, 16 bottles of beer on the wall.\n\n16 bottles of beer on the wall, 16 bottles of beer.\nTake one down and pass it around, 15 bottles of beer on the wall.\n\n15 bottles of beer on the wall, 15 bottles of beer.\nTake one down and pass it around, 14 bottles of beer on the wall.\n\n14 bottles of beer on the wall, 14 bottles of beer.\nTake one down and pass it around, 13 bottles of beer on the wall.\n\n13 bottles of beer on the wall, 13 bottles of beer.\nTake one down and pass it around, 12 bottles of beer on the wall.\n\n12 bottles of beer on the wall, 12 bottles of beer.\nTake one down and pass it around, 11 bottles of beer on the wall.\n\n11 bottles of beer on the wall, 11 bottles of beer.\nTake one down and pass it around, 10 bottles of beer on the wall.\n\n10 bottles of beer on the wall, 10 bottles of beer.\nTake one down and pass it around, 9 bottles of beer on the wall.\n\n9 bottles of beer on the wall, 9 bottles of beer.\nTake one down and pass it around, 8 bottles of beer on the wall.\n\n8 bottles of beer on the wall, 8 bottles of beer.\nTake one down and pass it around, 7 bottles of beer on the wall.\n\n7 bottles of beer on the wall, 7 bottles of beer.\nTake one down and pass it around, 6 bottles of beer on the wall.\n\n6 bottles of beer on the wall, 6 bottles of beer.\nTake one down and pass it around, 5 bottles of beer on the wall.\n\n5 bottles of beer on the wall, 5 bottles of beer.\nTake one down and pass it around, 4 bottles of beer on the wall.\n\n4 bottles of beer on the wall, 4 bottles of beer.\nTake one down and pass it around, 3 bottles of beer on the wall.\n\n3 bottles of beer on the wall, 3 bottles of beer.\nTake one down and pass it around, 2 bottles of beer on the wall.\n\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer.\nTake it down and pass it around, no more bottles of beer on the wall.\n\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n```\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these\nare some additional things you could try:\n\n* Remove as much duplication as you possibly can.\n* Optimize for readability, even if it means introducing duplication.\n* If you've removed all the duplication, do you have a lot of\n  conditionals? Try replacing the conditionals with polymorphism, if it\n  applies in this language. How readable is it?\n\nThen please share your thoughts in a comment on the submission. Did this\nexperiment make the code better? Worse? Did you learn anything from it?\n\n", "code": "beer_song.clj\n(ns beer-song)\n\n(defn verse\n  \"Returns the nth verse of the song.\"\n  [num]\n  (let [bottles (fn [n] (cond\n                          (= n 0) \"no more\"\n                          (= n 1) \"1\"\n                          :else (str n)))\n        bottles-caps (fn [n] (if (= n 1) \"bottle\" \"bottles\"))]\n    (str (clojure.string/capitalize (bottles num)) \" \" (bottles-caps num) \" of beer on the wall, \"\n         (bottles num) \" \" (bottles-caps num) \" of beer.\\n\"\n         (if (= num 0)\n           \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\"\n           (str \"Take \" (if (= num 1) \"it\" \"one\") \" down and pass it around, \"\n                (bottles (dec num)) \" \" (bottles-caps (dec num)) \" of beer on the wall.\\n\")))))\n\n(defn sing\n  \"Given a start and an optional end, returns all verses in this interval. If\n  end is not given, the whole song from start is sung.\"\n  ([start] (sing start 0))\n  ([start end]\n   (apply str (interpose \"\\n\" (map verse (range start (dec end) -1))))))\n", "test-output": "test_output.txt\n\nlein test beer-song-test\n\nRan 6 tests containing 6 assertions.\n0 failures, 0 errors.\n"},{"iterations": 1, "passed": true, "test": "binary", "tokens": 1968, "instructions": "instructions.md\n# Instructions\n\nConvert a binary number, represented as a string (e.g. '101010'), to its decimal equivalent using first principles.\n\nImplement binary to decimal conversion. Given a binary input\nstring, your program should produce a decimal output. The\nprogram should handle invalid inputs.\n\n## Note\n\n- Implement the conversion yourself.\n  Do not use something else to perform the conversion for you.\n\n## About Binary (Base-2)\n\nDecimal is a base-10 system.\n\nA number 23 in base 10 notation can be understood\nas a linear combination of powers of 10:\n\n- The rightmost digit gets multiplied by 10^0 = 1\n- The next number gets multiplied by 10^1 = 10\n- ...\n- The *n*th number gets multiplied by 10^*(n-1)*.\n- All these values are summed.\n\nSo: `23 => 2*10^1 + 3*10^0 => 2*10 + 3*1 = 23 base 10`\n\nBinary is similar, but uses powers of 2 rather than powers of 10.\n\nSo: `101 => 1*2^2 + 0*2^1 + 1*2^0 => 1*4 + 0*2 + 1*1 => 4 + 1 => 5 base 10`.\n\n", "code": "binary.clj\n(ns binary)\n\n(defn to-decimal [binary-string]\n  (try\n    (reduce (fn [acc cur] (+ (* acc 2) (if (= cur \\1) 1 0)))\n            0\n            (if (re-matches #\"^[01]*$\" binary-string)\n              binary-string\n              (throw (IllegalArgumentException. \"Invalid binary string\"))))\n    (catch IllegalArgumentException e 0)))\n", "test-output": "test_output.txt\n\nlein test binary-test\n\nRan 8 tests containing 8 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "binary-search", "response": "The coder failed the test due to a syntax error. The function \"middle\" is not recognized in the given context, causing the code to fail compilation.\n\nreason: syntax\n", "reason": "syntax", "tokens": 5039, "instructions": "instructions.md\n# Instructions\n\nYour task is to implement a binary search algorithm.\n\nA binary search algorithm finds an item in a list by repeatedly splitting it in half, only keeping the half which contains the item we're looking for.\nIt allows us to quickly narrow down the possible locations of our item until we find it, or until we've eliminated all possible locations.\n\n~~~~exercism/caution\nBinary search only works when a list has been sorted.\n~~~~\n\nThe algorithm looks like this:\n\n- Find the middle element of a *sorted* list and compare it with the item we're looking for.\n- If the middle element is our item, then we're done!\n- If the middle element is greater than our item, we can eliminate that element and all the elements **after** it.\n- If the middle element is less than our item, we can eliminate that element and all the elements **before** it.\n- If every element of the list has been eliminated then the item is not in the list.\n- Otherwise, repeat the process on the part of the list that has not been eliminated.\n\nHere's an example:\n\nLet's say we're looking for the number 23 in the following sorted list: `[4, 8, 12, 16, 23, 28, 32]`.\n\n- We start by comparing 23 with the middle element, 16.\n- Since 23 is greater than 16, we can eliminate the left half of the list, leaving us with `[23, 28, 32]`.\n- We then compare 23 with the new middle element, 28.\n- Since 23 is less than 28, we can eliminate the right half of the list: `[23]`.\n- We've found our item.\n\nintroduction.md\n# Introduction\n\nYou have stumbled upon a group of mathematicians who are also singer-songwriters.\nThey have written a song for each of their favorite numbers, and, as you can imagine, they have a lot of favorite numbers (like [0][zero] or [73][seventy-three] or [6174][kaprekars-constant]).\n\nYou are curious to hear the song for your favorite number, but with so many songs to wade through, finding the right song could take a while.\nFortunately, they have organized their songs in a playlist sorted by the title \u2014 which is simply the number that the song is about.\n\nYou realize that you can use a binary search algorithm to quickly find a song given the title.\n\n[zero]: https://en.wikipedia.org/wiki/0\n[seventy-three]: https://en.wikipedia.org/wiki/73_(number)\n[kaprekars-constant]: https://en.wikipedia.org/wiki/6174_(number)\n\n", "code": "binary_search.clj\n(ns binary-search)\n\n(defn search-for [target sorted-list]\n  (loop [start 0\n         end (dec (count sorted-list))]\n    (if (> start end)\n      -1\n      (let [mid (middle start end)]\n        (cond\n          (= (nth sorted-list mid) target) mid\n          (< (nth sorted-list mid) target) (recur (inc start) end)\n          :else (recur start (dec end)))))))\n\n(defn middle [start end]\n  (quot (+ start end) 2))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (binary_search.clj:8:17).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3820)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6384)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2837)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6436)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:596)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler.eval(Compiler.java:7180)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat binary_search_test$eval422$loading__6706__auto____423.invoke(binary_search_test.clj:1)\n\tat binary_search_test$eval422.invokeStatic(binary_search_test.clj:1)\n\tat binary_search_test$eval422.invoke(binary_search_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init10946919185993862641.clj:1)\n\tat user$eval224.invoke(form-init10946919185993862641.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unable to resolve symbol: middle in this context\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7413)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 105 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "binary-search-tree", "response": "The coder failed the test due to a NullPointerException being thrown in the insert function. This is likely caused by an issue with the logic of handling nil values in the binary search tree.\n\nreason: logic\n", "reason": "logic", "tokens": 6494, "instructions": "instructions.md\n# Instructions\n\nInsert and search for numbers in a binary tree.\n\nWhen we need to represent sorted data, an array does not make a good\ndata structure.\n\nSay we have the array `[1, 3, 4, 5]`, and we add 2 to it so it becomes\n`[1, 3, 4, 5, 2]` now we must sort the entire array again! We can\nimprove on this by realizing that we only need to make space for the new\nitem `[1, nil, 3, 4, 5]`, and then adding the item in the space we\nadded. But this still requires us to shift many elements down by one.\n\nBinary Search Trees, however, can operate on sorted data much more\nefficiently.\n\nA binary search tree consists of a series of connected nodes. Each node\ncontains a piece of data (e.g. the number 3), a variable named `left`,\nand a variable named `right`. The `left` and `right` variables point at\n`nil`, or other nodes. Since these other nodes in turn have other nodes\nbeneath them, we say that the left and right variables are pointing at\nsubtrees. All data in the left subtree is less than or equal to the\ncurrent node's data, and all data in the right subtree is greater than\nthe current node's data.\n\nFor example, if we had a node containing the data 4, and we added the\ndata 2, our tree would look like this:\n\n      4\n     /\n    2\n\nIf we then added 6, it would look like this:\n\n      4\n     / \\\n    2   6\n\nIf we then added 3, it would look like this\n\n       4\n     /   \\\n    2     6\n     \\\n      3\n\nAnd if we then added 1, 5, and 7, it would look like this\n\n          4\n        /   \\\n       /     \\\n      2       6\n     / \\     / \\\n    1   3   5   7\n\n", "code": "binary_search_tree.clj\n(ns binary-search-tree)\n\n(defn value [node]\n  (:value node))\n\n(defn singleton [v]\n  {:value v :left nil :right nil})\n\n(defn insert [node v]\n  (if (nil? node)\n    (singleton v)\n    (let [node-value (:value node)]\n      (cond\n        (< v node-value) (assoc node :left (insert (:left node) v))\n        (> v node-value) (assoc node :right (insert (:right node) v))\n        :else node))))\n\n(defn left [node]\n  (:left node))\n\n(defn right [node]\n  (:right node))\n\n(defn to-list [node]\n  (if (nil? node)\n    []\n    (concat (to-list (:left node)) [(value node)] (to-list (:right node)))))\n\n(defn from-list [values]\n  (reduce insert nil values))\n", "test-output": "test_output.txt\n\nlein test binary-search-tree-test\n\nlein test :only binary-search-tree-test/inserting-right\n\nERROR in (inserting-right) (Numbers.java:1068)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: java.lang.NullPointerException: null\n at clojure.lang.Numbers.ops (Numbers.java:1068)\n    clojure.lang.Numbers.lt (Numbers.java:251)\n    binary_search_tree$insert.invokeStatic (binary_search_tree.clj:14)\n    binary_search_tree$insert.invoke (binary_search_tree.clj:9)\n    binary_search_tree_test$fn__470.invokeStatic (binary_search_tree_test.clj:19)\n    binary_search_tree_test/fn (binary_search_tree_test.clj:18)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16712498967275513143.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16712498967275513143.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16712498967275513143.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16712498967275513143.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16712498967275513143.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16712498967275513143.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16712498967275513143.clj:1)\n    user$eval224$fn__357.invoke (form-init16712498967275513143.clj:1)\n    user$eval224.invokeStatic (form-init16712498967275513143.clj:1)\n    user$eval224.invoke (form-init16712498967275513143.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only binary-search-tree-test/inserting-less\n\nERROR in (inserting-less) (Numbers.java:1068)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: java.lang.NullPointerException: null\n at clojure.lang.Numbers.ops (Numbers.java:1068)\n    clojure.lang.Numbers.lt (Numbers.java:251)\n    binary_search_tree$insert.invokeStatic (binary_search_tree.clj:14)\n    binary_search_tree$insert.invoke (binary_search_tree.clj:9)\n    binary_search_tree_test$fn__452.invokeStatic (binary_search_tree_test.clj:9)\n    binary_search_tree_test/fn (binary_search_tree_test.clj:8)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16712498967275513143.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16712498967275513143.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16712498967275513143.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16712498967275513143.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16712498967275513143.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16712498967275513143.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16712498967275513143.clj:1)\n    user$eval224$fn__357.invoke (form-init16712498967275513143.clj:1)\n    user$eval224.invokeStatic (form-init16712498967275513143.clj:1)\n    user$eval224.invoke (form-init16712498967275513143.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only binary-search-tree-test/inserting-same\n\nERROR in (inserting-same) (Numbers.java:1068)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: java.lang.NullPointerException: null\n at clojure.lang.Numbers.ops (Numbers.java:1068)\n    clojure.lang.Numbers.lt (Numbers.java:251)\n    binary_search_tree$insert.invokeStatic (binary_search_tree.clj:14)\n    binary_search_tree$insert.invoke (binary_search_tree.clj:9)\n    binary_search_tree_test$fn__461.invokeStatic (binary_search_tree_test.clj:14)\n    binary_search_tree_test/fn (binary_search_tree_test.clj:13)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16712498967275513143.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16712498967275513143.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16712498967275513143.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16712498967275513143.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16712498967275513143.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16712498967275513143.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16712498967275513143.clj:1)\n    user$eval224$fn__357.invoke (form-init16712498967275513143.clj:1)\n    user$eval224.invokeStatic (form-init16712498967275513143.clj:1)\n    user$eval224.invoke (form-init16712498967275513143.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 9 tests containing 15 assertions.\n0 failures, 3 errors.\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "bob", "tokens": 4939, "instructions": "instructions.md\n# Instructions\n\nYour task is to determine what Bob will reply to someone when they say something to him or ask him a question.\n\nBob only ever answers one of five things:\n\n- **\"Sure.\"**\n  This is his response if you ask him a question, such as \"How are you?\"\n  The convention used for questions is that it ends with a question mark.\n- **\"Whoa, chill out!\"**\n  This is his answer if you YELL AT HIM.\n  The convention used for yelling is ALL CAPITAL LETTERS.\n- **\"Calm down, I know what I'm doing!\"**\n  This is what he says if you yell a question at him.\n- **\"Fine. Be that way!\"**\n  This is how he responds to silence.\n  The convention used for silence is nothing, or various combinations of whitespace characters.\n- **\"Whatever.\"**\n  This is what he answers to anything else.\n\nintroduction.md\n# Introduction\n\nBob is a [lackadaisical][] teenager.\nHe likes to think that he's very cool.\nAnd he definitely doesn't get excited about things.\nThat wouldn't be cool.\n\nWhen people talk to him, his responses are pretty limited.\n\n[lackadaisical]: https://www.collinsdictionary.com/dictionary/english/lackadaisical\n\n", "code": "bob.clj\n(ns bob)\n\n(defn response-for [s]\n  (let [trimmed-s (clojure.string/trim s)]\n    (cond\n      (and (re-find #\"\\?$\" trimmed-s) (not (re-find #\"[a-z]\" trimmed-s)) (re-find #\"[A-Z]\" trimmed-s)) \"Calm down, I know what I'm doing!\"\n      (re-find #\"\\?$\" trimmed-s) \"Sure.\"\n      (and (not (re-find #\"[a-z]\" trimmed-s)) (re-find #\"[A-Z]\" trimmed-s)) \"Whoa, chill out!\"\n      (clojure.string/blank? trimmed-s) \"Fine. Be that way!\"\n      :else \"Whatever.\")))\n", "test-output": "test_output.txt\n\nlein test bob-test\n\nRan 25 tests containing 25 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "change", "response": "The coder failed the test because there is a syntax error in the code. The error occurred while reading the file, starting at line 3, causing the tests to fail.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4310, "instructions": "instructions.md\n# Instructions\n\nCorrectly determine the fewest number of coins to be given to a customer such\nthat the sum of the coins' value would equal the correct amount of change.\n\n## For example\n\n- An input of 15 with [1, 5, 10, 25, 100] should return one nickel (5)\n  and one dime (10) or [5, 10]\n- An input of 40 with [1, 5, 10, 25, 100] should return one nickel (5)\n  and one dime (10) and one quarter (25) or [5, 10, 25]\n\n## Edge cases\n\n- Does your algorithm work for any given set of coins?\n- Can you ask for negative change?\n- Can you ask for a change value smaller than the smallest coin value?\n\n", "code": "change.clj\n(ns change)\n\n(defn issue [change coins]\n  (if (neg? change) nil\n      (let [dp (vec (cons 0 (repeat change Double/POSITIVE_INFINITY)))]\n        (doseq [coin coins\n                amount (range coin (inc change))]\n          (aset dp amount (min (aget dp amount) (inc (aget dp (- amount coin))))))\n        (if (= (aget dp change) Double/POSITIVE_INFINITY) nil\n            (loop [remaining-change change\n                   remaining-coins (reverse coins)\n                   result []]\n              (if (zero? remaining-change) result\n                  (let [coin (first remaining-coins)]\n                    (if (<= (- remaining-change coin) 0)\n                        (recur remaining-change (rest remaining-coins) result)\n                        (recur (- remaining-change coin) remaining-coins (conj result coin))))))))) \n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (change.clj:18:1).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat change_test$eval422$loading__6706__auto____423.invoke(change_test.clj:1)\n\tat change_test$eval422.invokeStatic(change_test.clj:1)\n\tat change_test$eval422.invoke(change_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init9414767384530779405.clj:1)\n\tat user$eval224.invoke(form-init9414767384530779405.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: EOF while reading, starting at line 3\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1405)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "clock", "response": "The coder failed the test because the logic for calculating the hours in the `clock` and `add-time` functions is incorrect. The code adds an unnecessary `(mod total-minutes 60)` to the total-minutes before taking the modulo with 1440 and dividing by 60. This causes the hour value to be incorrectly calculated in multiple test cases.\n\nreason: logic\n", "reason": "logic", "tokens": 4449, "instructions": "instructions.md\n# Instructions\n\nImplement a clock that handles times without dates.\n\nYou should be able to add and subtract minutes to it.\n\nTwo clocks that represent the same time should be equal to each other.\n\n", "code": "clock.clj\n(ns clock)\n\n(defn clock->string [clock]\n  (format \"%02d:%02d\" (mod (first clock) 24) (mod (second clock) 60)))\n\n(defn clock [hours minutes]\n  (let [total-minutes (+ (* hours 60) minutes)\n        hours (quot (mod (+ (mod total-minutes 60) total-minutes) 1440) 60)\n        minutes (mod total-minutes 60)]\n    [hours minutes]))\n(defn add-time [clock time]\n  (let [total-minutes (+ (* (first clock) 60) (second clock) time)\n        hours (quot (mod (+ (mod total-minutes 60) total-minutes) 1440) 60)\n        minutes (mod total-minutes 60)]\n    [hours minutes]))", "test-output": "test_output.txt\n\nlein test clock-test\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:72)\nadd no minutes\nexpected: (= \"06:41\" test-clock)\n  actual: (not (= \"06:41\" \"08:41\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:75)\nadd to next hour\nexpected: (= \"01:25\" test-clock)\n  actual: (not (= \"01:25\" \"02:25\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:81)\nadd more than two hours with carry\nexpected: (= \"03:25\" test-clock)\n  actual: (not (= \"03:25\" \"04:25\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:84)\nadd across midnight\nexpected: (= \"00:01\" test-clock)\n  actual: (not (= \"00:01\" \"01:01\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:87)\nadd more than one day (1500 min = 25 hrs)\nexpected: (= \"06:32\" test-clock)\n  actual: (not (= \"06:32\" \"08:32\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:96)\nsubtract to previous hour\nexpected: (= \"09:33\" test-clock)\n  actual: (not (= \"09:33\" \"10:33\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:99)\nsubtract more than an hour\nexpected: (= \"08:53\" test-clock)\n  actual: (not (= \"08:53\" \"09:53\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:102)\nsubtract across midnight\nexpected: (= \"23:59\" test-clock)\n  actual: (not (= \"23:59\" \"00:59\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:108)\nsubtract more than two hours with borrow\nexpected: (= \"03:35\" test-clock)\n  actual: (not (= \"03:35\" \"04:35\"))\n\nlein test :only clock-test/add-time-test\n\nFAIL in (add-time-test) (clock_test.clj:111)\nsubtract more than one day (1500 min = 25 hrs)\nexpected: (= \"04:32\" test-clock)\n  actual: (not (= \"04:32\" \"06:32\"))\n\nlein test :only clock-test/create-clock-test\n\nFAIL in (create-clock-test) (clock_test.clj:27)\nminutes roll over\nexpected: (= \"02:40\" test-clock)\n  actual: (not (= \"02:40\" \"03:40\"))\n\nlein test :only clock-test/create-clock-test\n\nFAIL in (create-clock-test) (clock_test.clj:30)\nminutes roll over continuously\nexpected: (= \"04:43\" test-clock)\n  actual: (not (= \"04:43\" \"05:43\"))\n\nlein test :only clock-test/create-clock-test\n\nFAIL in (create-clock-test) (clock_test.clj:33)\nhour and minutes roll over\nexpected: (= \"03:40\" test-clock)\n  actual: (not (= \"03:40\" \"04:40\"))\n\nlein test :only clock-test/create-clock-test\n\nFAIL in (create-clock-test) (clock_test.clj:57)\nnegative minutes roll over continuously\nexpected: (= \"16:40\" test-clock)\n  actual: (not (= \"16:40\" \"17:40\"))\n\nRan 3 tests containing 50 assertions.\n14 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "collatz-conjecture", "tokens": 3935, "instructions": "instructions.md\n# Instructions\n\nThe Collatz Conjecture or 3x+1 problem can be summarized as follows:\n\nTake any positive integer n. If n is even, divide n by 2 to get n / 2. If n is\nodd, multiply n by 3 and add 1 to get 3n + 1. Repeat the process indefinitely.\nThe conjecture states that no matter which number you start with, you will\nalways reach 1 eventually.\n\nGiven a number n, return the number of steps required to reach 1.\n\n## Examples\n\nStarting with n = 12, the steps would be as follows:\n\n0. 12\n1. 6\n2. 3\n3. 10\n4. 5\n5. 16\n6. 8\n7. 4\n8. 2\n9. 1\n\nResulting in 9 steps. So for input n = 12, the return value would be 9.\n\n", "code": "collatz_conjecture.clj\n(ns collatz-conjecture)\n\n(defn collatz [num]\n  (if (<= num 0)\n    (throw (IllegalArgumentException. \"Input must be a positive integer\"))\n    (loop [n num steps 0]\n      (if (= n 1)\n        steps\n        (recur (if (even? n) (/ n 2) (+ (* 3 n) 1)) (inc steps))))))\n", "test-output": "test_output.txt\n\nlein test collatz-conjecture-test\n\nRan 6 tests containing 6 assertions.\n0 failures, 0 errors.\n"},{"iterations": 1, "passed": true, "test": "complex-numbers", "tokens": 2864, "instructions": "instructions.md\n# Instructions\n\nA complex number is a number in the form `a + b * i` where `a` and `b` are real and `i` satisfies `i^2 = -1`.\n\n`a` is called the real part and `b` is called the imaginary part of `z`.\nThe conjugate of the number `a + b * i` is the number `a - b * i`.\nThe absolute value of a complex number `z = a + b * i` is a real number `|z| = sqrt(a^2 + b^2)`. The square of the absolute value `|z|^2` is the result of multiplication of `z` by its complex conjugate.\n\nThe sum/difference of two complex numbers involves adding/subtracting their real and imaginary parts separately:\n`(a + i * b) + (c + i * d) = (a + c) + (b + d) * i`,\n`(a + i * b) - (c + i * d) = (a - c) + (b - d) * i`.\n\nMultiplication result is by definition\n`(a + i * b) * (c + i * d) = (a * c - b * d) + (b * c + a * d) * i`.\n\nThe reciprocal of a non-zero complex number is\n`1 / (a + i * b) = a/(a^2 + b^2) - b/(a^2 + b^2) * i`.\n\nDividing a complex number `a + i * b` by another `c + i * d` gives:\n`(a + i * b) / (c + i * d) = (a * c + b * d)/(c^2 + d^2) + (b * c - a * d)/(c^2 + d^2) * i`.\n\nRaising e to a complex exponent can be expressed as `e^(a + i * b) = e^a * e^(i * b)`, the last term of which is given by Euler's formula `e^(i * b) = cos(b) + i * sin(b)`.\n\nImplement the following operations:\n\n- addition, subtraction, multiplication and division of two complex numbers,\n- conjugate, absolute value of a given complex number.\n\nAssume the programming language you are using does not have an implementation of complex numbers.\n\n", "code": "complex_numbers.clj\n(ns complex-numbers)\n\n(defn real [[a b]]\n  a)\n\n(defn imaginary [[a b]]\n  b)\n\n(defn abs [[a b]]\n  (Math/sqrt (+ (* a a) (* b b))))\n\n(defn conjugate [[a b]]\n  [a (- 0 b)])\n\n(defn add [[a b] [c d]]\n  [(+ a c) (+ b d)])\n\n(defn sub [[a b] [c d]]\n  [(- a c) (- b d)])\n\n(defn mul [[a b] [c d]]\n  [(- (* a c) (* b d)) (+ (* a d) (* b c))])\n\n(defn div [[a b] [c d]]\n  (let [denom (+ (* c c) (* d d))]\n    [(/ (+ (* a c) (* b d)) denom) (/ (- (* b c) (* a d)) denom)]))\n", "test-output": "test_output.txt\n\nlein test complex-numbers-test\n\nRan 35 tests containing 35 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "crypto-square", "response": "The coder failed the test because the output of the ciphertext and normalize-ciphertext functions are not as expected. The issues seem to be related to incorrect spacing and chunking of the output.\n\nreason: logic\n", "reason": "logic", "tokens": 7022, "instructions": "instructions.md\n# Instructions\n\nImplement the classic method for composing secret messages called a square code.\n\nGiven an English text, output the encoded version of that text.\n\nFirst, the input is normalized: the spaces and punctuation are removed\nfrom the English text and the message is downcased.\n\nThen, the normalized characters are broken into rows.  These rows can be\nregarded as forming a rectangle when printed with intervening newlines.\n\nFor example, the sentence\n\n```text\n\"If man was meant to stay on the ground, god would have given us roots.\"\n```\n\nis normalized to:\n\n```text\n\"ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots\"\n```\n\nThe plaintext should be organized in to a rectangle.  The size of the\nrectangle (`r x c`) should be decided by the length of the message,\nsuch that `c >= r` and `c - r <= 1`, where `c` is the number of columns\nand `r` is the number of rows.\n\nOur normalized text is 54 characters long, dictating a rectangle with\n`c = 8` and `r = 7`:\n\n```text\n\"ifmanwas\"\n\"meanttos\"\n\"tayonthe\"\n\"groundgo\"\n\"dwouldha\"\n\"vegivenu\"\n\"sroots  \"\n```\n\nThe coded message is obtained by reading down the columns going left to\nright.\n\nThe message above is coded as:\n\n```text\n\"imtgdvsfearwermayoogoanouuiontnnlvtwttddesaohghnsseoau\"\n```\n\nOutput the encoded text in chunks that fill perfect rectangles `(r X c)`,\nwith `c` chunks of `r` length, separated by spaces. For phrases that are\n`n` characters short of the perfect rectangle, pad each of the last `n`\nchunks with a single trailing space.\n\n```text\n\"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau \"\n```\n\nNotice that were we to stack these, we could visually decode the\nciphertext back in to the original message:\n\n```text\n\"imtgdvs\"\n\"fearwer\"\n\"mayoogo\"\n\"anouuio\"\n\"ntnnlvt\"\n\"wttddes\"\n\"aohghn \"\n\"sseoau \"\n```\n\n", "code": "crypto_square.clj\n(ns crypto-square)\n\n(defn normalize-plaintext [text]\n  (clojure.string/replace (clojure.string/lower-case text) #\"[^a-z0-9]\" \"\"))\n\n(defn square-size [text]\n  (let [len (count text)]\n    (if (zero? len) 0 (int (Math/ceil (Math/sqrt len))))))\n(defn plaintext-segments [text]\n  (let [c (square-size text)\n        padded-text (apply str (concat text (repeat (- (* c (int (Math/ceil (/ (count text) c)))) (count text)) \" \")))]\n    (partition c c padded-text)))\n(defn ciphertext [text]\n  (apply str (mapcat #(apply str %) (apply map vector (plaintext-segments (normalize-plaintext text))))))\n(defn normalize-ciphertext [text]\n  (let [c (square-size (normalize-plaintext text))]\n    (clojure.string/join \" \" (map #(apply str %) (partition c c (ciphertext text))))))", "test-output": "test_output.txt\n\nlein test crypto-square-test\n\nlein test :only crypto-square-test/cipher-6\n\nFAIL in (cipher-6) (crypto_square_test.clj:47)\nexpected: (= \"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau \" (crypto-square/normalize-ciphertext \"If man was meant to stay on the ground, god would have given us roots.\"))\n  actual: (not (= \"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau \" \"imtgdvsf earwerma yoogoano uuiontnn lvtwttdd esaohghn  sseoau \"))\n\nlein test :only crypto-square-test/cipher-2\n\nFAIL in (cipher-2) (crypto_square_test.clj:28)\nexpected: (= \"wneiaweoreneawssciliprerlneoidktcms\" (crypto-square/ciphertext \"We all know interspecies romance is weird.\"))\n  actual: (not (= \"wneiaweoreneawssciliprerlneoidktcms\" \"wneiaweoreneawssciliprerlneoidktcms \"))\n\nlein test :only crypto-square-test/cipher-4\n\nFAIL in (cipher-4) (crypto_square_test.clj:34)\nexpected: (= \"msemo aanin dnin  ndla  etlt  shui \" (crypto-square/normalize-ciphertext \"Madness, and then illumination.\"))\n  actual: (not (= \"msemo aanin dnin  ndla  etlt  shui \" \"msemoa anindn in ndl a etlt  shui \"))\n\nlein test :only crypto-square-test/cipher-1\n\nFAIL in (cipher-1) (crypto_square_test.clj:25)\nexpected: (= \"tasneyinicdsmiohooelntuillibsuuml\" (crypto-square/ciphertext \"Time is an illusion. Lunchtime doubly so.\"))\n  actual: (not (= \"tasneyinicdsmiohooelntuillibsuuml\" \"tasneyinicdsmiohooelntu illib suuml \"))\n\nlein test :only crypto-square-test/segments\n\nFAIL in (segments) (crypto_square_test.clj:18)\nexpected: (= [\"neverv\" \"exthin\" \"eheart\" \"withid\" \"lewoes\"] (crypto-square/plaintext-segments \"Never vex thine heart with idle woes.\"))\n  actual: (not (= [\"neverv\" \"exthin\" \"eheart\" \"withid\" \"lewoes\"] ((\\N \\e \\v \\e \\r \\space \\v) (\\e \\x \\space \\t \\h \\i \\n) (\\e \\space \\h \\e \\a \\r \\t) (\\space \\w \\i \\t \\h \\space \\i) (\\d \\l \\e \\space \\w \\o \\e) (\\s \\. \\space \\space \\space \\space \\space))))\n\nlein test :only crypto-square-test/cipher-3\n\nFAIL in (cipher-3) (crypto_square_test.clj:31)\nexpected: (= \"vrel aepe mset paoo irpo\" (crypto-square/normalize-ciphertext \"Vampires are people too!\"))\n  actual: (not (= \"vrel aepe mset paoo irpo\" \"vrela epems etpao oirpo\"))\n\nlein test :only crypto-square-test/segments-2\n\nFAIL in (segments-2) (crypto_square_test.clj:21)\nexpected: (= [\"zomg\" \"zomb\" \"ies\"] (crypto-square/plaintext-segments \"ZOMG! ZOMBIES!!!\"))\n  actual: (not (= [\"zomg\" \"zomb\" \"ies\"] ((\\Z \\O \\M \\G) (\\! \\space \\Z \\O) (\\M \\B \\I \\E) (\\S \\! \\! \\!))))\n\nRan 13 tests containing 13 assertions.\n7 failures, 0 errors.\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "diamond", "tokens": 1989, "instructions": "instructions.md\n# Instructions\n\nThe diamond kata takes as its input a letter, and outputs it in a diamond\nshape. Given a letter, it prints a diamond starting with 'A', with the\nsupplied letter at the widest point.\n\n## Requirements\n\n* The first row contains one 'A'.\n* The last row contains one 'A'.\n* All rows, except the first and last, have exactly two identical letters.\n* All rows have as many trailing spaces as leading spaces. (This might be 0).\n* The diamond is horizontally symmetric.\n* The diamond is vertically symmetric.\n* The diamond has a square shape (width equals height).\n* The letters form a diamond shape.\n* The top half has the letters in ascending order.\n* The bottom half has the letters in descending order.\n* The four corners (containing the spaces) are triangles.\n\n## Examples\n\nIn the following examples, spaces are indicated by `\u00b7` characters.\n\nDiamond for letter 'A':\n\n```text\nA\n```\n\nDiamond for letter 'C':\n\n```text\n\u00b7\u00b7A\u00b7\u00b7\n\u00b7B\u00b7B\u00b7\nC\u00b7\u00b7\u00b7C\n\u00b7B\u00b7B\u00b7\n\u00b7\u00b7A\u00b7\u00b7\n```\n\nDiamond for letter 'E':\n\n```text\n\u00b7\u00b7\u00b7\u00b7A\u00b7\u00b7\u00b7\u00b7\n\u00b7\u00b7\u00b7B\u00b7B\u00b7\u00b7\u00b7\n\u00b7\u00b7C\u00b7\u00b7\u00b7C\u00b7\u00b7\n\u00b7D\u00b7\u00b7\u00b7\u00b7\u00b7D\u00b7\nE\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7E\n\u00b7D\u00b7\u00b7\u00b7\u00b7\u00b7D\u00b7\n\u00b7\u00b7C\u00b7\u00b7\u00b7C\u00b7\u00b7\n\u00b7\u00b7\u00b7B\u00b7B\u00b7\u00b7\u00b7\n\u00b7\u00b7\u00b7\u00b7A\u00b7\u00b7\u00b7\u00b7\n```\n\n", "code": "diamond.clj\n(ns diamond)\n\n(defn diamond [letter]\n  (let [size (- (int letter) 64)\n        build-row (fn [i]\n                    (let [spaces (apply str (repeat (- size i) \" \"))\n                          letter (char (+ 64 i))]\n                      (if (= i 1)\n                        (str spaces letter spaces)\n                        (str spaces letter (apply str (repeat (- (* 2 i) 3) \" \")) letter spaces))))]\n    (concat\n     (map build-row (range 1 (inc size)))\n     (reverse (map build-row (range 1 size))))))\n", "test-output": "test_output.txt\n\nlein test diamond-test\n\nRan 5 tests containing 5 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "difference-of-squares", "response": "The coder failed the test due to a syntax error in their code. The error message indicates that the symbol \"square-of-sum\" could not be resolved in the given context.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4366, "instructions": "instructions.md\n# Instructions\n\nFind the difference between the square of the sum and the sum of the squares of the first N natural numbers.\n\nThe square of the sum of the first ten natural numbers is\n(1 + 2 + ... + 10)\u00b2 = 55\u00b2 = 3025.\n\nThe sum of the squares of the first ten natural numbers is\n1\u00b2 + 2\u00b2 + ... + 10\u00b2 = 385.\n\nHence the difference between the square of the sum of the first\nten natural numbers and the sum of the squares of the first ten\nnatural numbers is 3025 - 385 = 2640.\n\nYou are not expected to discover an efficient solution to this yourself from\nfirst principles; research is allowed, indeed, encouraged. Finding the best\nalgorithm for the problem is a key skill in software engineering.\n\n", "code": "difference_of_squares.clj\n(ns difference-of-squares)\n\n(defn difference [n]\n  (- (square-of-sum n) (sum-of-squares n)))\n(defn sum-of-squares [n]\n  (/ (* n (inc n) (* (+ n n 1) 2)) 6))\n(defn square-of-sum [n]\n  (let [sum (/ (* n (inc n)) 2)]\n    (* sum sum)))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (difference_of_squares.clj:4:6).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3820)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$HostExpr$Parser.parse(Compiler.java:1020)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7101)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:596)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler.eval(Compiler.java:7180)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat difference_of_squares_test$eval422$loading__6706__auto____423.invoke(difference_of_squares_test.clj:1)\n\tat difference_of_squares_test$eval422.invokeStatic(difference_of_squares_test.clj:1)\n\tat difference_of_squares_test$eval422.invoke(difference_of_squares_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init11261636352533511158.clj:1)\n\tat user$eval224.invoke(form-init11261636352533511158.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unable to resolve symbol: square-of-sum in this context\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7413)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 95 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "dominoes", "response": "The coder seems to have implemented the logic for checking if a chain can be formed and generating possible chains, but there is an extra, empty `can-chain?` function at the end of the code. This might be causing the code to not work as expected.\n\nreason: duplication\n", "reason": "duplication", "tokens": 4287, "instructions": "instructions.md\n# Instructions\n\nMake a chain of dominoes.\n\nCompute a way to order a given set of dominoes in such a way that they form a\ncorrect domino chain (the dots on one half of a stone match the dots on the\nneighbouring half of an adjacent stone) and that dots on the halves of the\nstones which don't have a neighbour (the first and last stone) match each other.\n\nFor example given the stones `[2|1]`, `[2|3]` and `[1|3]` you should compute something\nlike `[1|2] [2|3] [3|1]` or `[3|2] [2|1] [1|3]` or `[1|3] [3|2] [2|1]` etc, where the first and last numbers are the same.\n\nFor stones `[1|2]`, `[4|1]` and `[2|3]` the resulting chain is not valid: `[4|1] [1|2] [2|3]`'s first and last numbers are not the same. 4 != 3\n\nSome test cases may use duplicate stones in a chain solution, assume that multiple Domino sets are being used.\n\n", "code": "dominoes.clj\n(ns dominoes)\n\n(defn rotations [domino]\n  [domino (reverse domino)])\n\n(defn chains [dominoes]\n  (let [start (first dominoes)\n        remaining (rest dominoes)]\n    (if (empty? remaining)\n      (list start)\n      (for [next (mapcat rotations remaining)\n            :when (= (second start) (first next))\n            chain (chains (remove #{next} remaining))]\n        (cons start chain)))))\n\n(defn can-chain? [dominoes]\n  (let [counts (frequencies (flatten dominoes))\n        odd-counts (count (filter odd? (vals counts)))]\n    (if (empty? dominoes)\n      true\n      (and (<= odd-counts 2)\n           (or (= odd-counts 0)\n               (some #(= (first %) (second %))\n                     (mapcat #(list % (reverse %)) dominoes)))))))\n(defn can-chain? [] ;; <- arglist goes here\n  ;; your code goes here\n)\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "etl", "response": "The coder implemented the transform function to convert the input data to the required format. However, the test suite timed out, which might indicate that the code is inefficient or has an infinite loop.\n\nreason: other\n", "reason": "other", "tokens": 5130, "instructions": "instructions.md\n# Instructions\n\nYour task is to change the data format of letters and their point values in the game.\n\nCurrently, letters are stored in groups based on their score, in a one-to-many mapping.\n\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\n- 2 points: \"D\", \"G\",\n- 3 points: \"B\", \"C\", \"M\", \"P\",\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\n- 5 points: \"K\",\n- 8 points: \"J\", \"X\",\n- 10 points: \"Q\", \"Z\",\n\nThis needs to be changed to store each individual letter with its score in a one-to-one mapping.\n\n- \"a\" is worth 1 point.\n- \"b\" is worth 3 points.\n- \"c\" is worth 3 points.\n- \"d\" is worth 2 points.\n- etc.\n\nAs part of this change, the team has also decided to change the letters to be lower-case rather than upper-case.\n\n~~~~exercism/note\nIf you want to look at how the data was previously structured and how it needs to change, take a look at the examples in the test suite.\n~~~~\n\nintroduction.md\n# Introduction\n\nYou work for a company that makes an online multiplayer game called Lexiconia.\n\nTo play the game, each player is given 13 letters, which they must rearrange to create words.\nDifferent letters have different point values, since it's easier to create words with some letters than others.\n\nThe game was originally launched in English, but it is very popular, and now the company wants to expand to other languages as well.\n\nDifferent languages need to support different point values for letters.\nThe point values are determined by how often letters are used, compared to other letters in that language.\n\nFor example, the letter 'C' is quite common in English, and is only worth 3 points.\nBut in Norwegian it's a very rare letter, and is worth 10 points.\n\nTo make it easier to add new languages, your team needs to change the way letters and their point values are stored in the game.\n\n", "code": "etl.clj\n(ns etl)\n\n(defn transform [source]\n  (into {} (for [[score letters] source, letter letters]\n             [(clojure.string/lower-case (str letter)) score])))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": true, "test": "flatten-array", "tokens": 3462, "instructions": "instructions.md\n# Instructions\n\nTake a nested list and return a single flattened list with all values except nil/null.\n\nThe challenge is to write a function that accepts an arbitrarily-deep nested list-like structure and returns a flattened structure without any nil/null values.\n\nFor Example\n\ninput: [1,[2,3,null,4],[null],5]\n\noutput: [1,2,3,4,5]\n\n", "code": "flatten_array.clj\n(ns flatten-array)\n\n(defn flatten [arr]\n  (loop [input arr, output []]\n    (if (empty? input)\n      output\n      (let [elem (first input)]\n        (if (coll? elem)\n          (recur (concat elem (rest input)) output)\n          (recur (rest input) (if (nil? elem) output (conj output elem))))))))", "test-output": "test_output.txt\nWARNING: flatten already refers to: #'clojure.core/flatten in namespace: flatten-array, being replaced by: #'flatten-array/flatten\n\nlein test flatten-array-test\n\nRan 5 tests containing 5 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "gigasecond", "response": "The coder attempted to calculate the date after a gigasecond has passed. However, the test cases are expecting an array of [year, month, day] as output, while the code returns a LocalDateTime object. The output format does not match the expected format.\n\nreason: logic\n", "reason": "logic", "tokens": 5411, "instructions": "instructions.md\n# Instructions\n\nYour task is to determine the date and time one gigasecond after a certain date.\n\nA gigasecond is one thousand million seconds.\nThat is a one with nine zeros after it.\n\nIf you were born on _January 24th, 2015 at 22:00 (10:00:00pm)_, then you would be a gigasecond old on _October 2nd, 2046 at 23:46:40 (11:46:40pm)_.\n\nintroduction.md\n# Introduction\n\nThe way we measure time is kind of messy.\nWe have 60 seconds in a minute, and 60 minutes in an hour.\nThis comes from ancient Babylon, where they used 60 as the basis for their number system.\nWe have 24 hours in a day, 7 days in a week, and how many days in a month?\nWell, for days in a month it depends not only on which month it is, but also on what type of calendar is used in the country you live in.\n\nWhat if, instead, we only use seconds to express time intervals?\nThen we can use metric system prefixes for writing large numbers of seconds in more easily comprehensible quantities.\n\n- A food recipe might explain that you need to let the brownies cook in the oven for two kiloseconds (that's two thousand seconds).\n- Perhaps you and your family would travel to somewhere exotic for two megaseconds (that's two million seconds).\n- And if you and your spouse were married for _a thousand million_ seconds, you would celebrate your one gigasecond anniversary.\n\n~~~~exercism/note\nIf we ever colonize Mars or some other planet, measuring time is going to get even messier.\nIf someone says \"year\" do they mean a year on Earth or a year on Mars?\n\nThe idea for this exercise came from the science fiction novel [\"A Deepness in the Sky\"][vinge-novel] by author Vernor Vinge.\nIn it the author uses the metric system as the basis for time measurements.\n\n[vinge-novel]: https://www.tor.com/2017/08/03/science-fiction-with-something-for-everyone-a-deepness-in-the-sky-by-vernor-vinge/\n~~~~\n\n", "code": "gigasecond.clj\n(ns gigasecond)\n\n(defn from [year month day]\n  (let [gigasecond 1000000000\n        date (java.time.LocalDateTime/of year month day 0 0)\n        gigasecond-date (-> date\n                            (.toInstant (java.time.ZoneOffset/UTC))\n                            (.plusSeconds gigasecond)\n                            (.atZone (java.time.ZoneId/systemDefault))\n                            (.toLocalDateTime))]\n    gigasecond-date))\n", "test-output": "test_output.txt\n\nlein test gigasecond-test\n\nlein test :only gigasecond-test/from-apr-25-2011\n\nFAIL in (from-apr-25-2011) (gigasecond_test.clj:6)\nexpected: (= [2043 1 1] (gigasecond/from 2011 4 25))\n  actual: (not (= [2043 1 1] #object[java.time.LocalDateTime 0x47b2e9e1 \"2042-12-31T17:46:40\"]))\n\nlein test :only gigasecond-test/from-jun-13-1977\n\nFAIL in (from-jun-13-1977) (gigasecond_test.clj:9)\nexpected: (= [2009 2 19] (gigasecond/from 1977 6 13))\n  actual: (not (= [2009 2 19] #object[java.time.LocalDateTime 0x59942b48 \"2009-02-18T17:46:40\"]))\n\nlein test :only gigasecond-test/from-jul-19-1959\n\nFAIL in (from-jul-19-1959) (gigasecond_test.clj:12)\nexpected: (= [1991 3 27] (gigasecond/from 1959 7 19))\n  actual: (not (= [1991 3 27] #object[java.time.LocalDateTime 0x1869f114 \"1991-03-26T17:46:40\"]))\n\nRan 3 tests containing 3 assertions.\n3 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "go-counting", "response": "The coder failed the test because their implementation did not produce the expected output for the given test cases. The output keys and values in the territory and territories functions do not match the expected results from the test suite.\n\nreason: logic\n", "reason": "logic", "tokens": 5954, "instructions": "instructions.md\n# Instructions\n\nCount the scored points on a Go board.\n\nIn the game of go (also known as baduk, igo, c\u1edd v\u00e2y and w\u00e9iq\u00ed) points\nare gained by completely encircling empty intersections with your\nstones. The encircled intersections of a player are known as its\nterritory.\n\nWrite a function that determines the territory of each player. You may\nassume that any stones that have been stranded in enemy territory have\nalready been taken off the board.\n\nWrite a function that determines the territory which includes a specified coordinate.\n\nMultiple empty intersections may be encircled at once and for encircling\nonly horizontal and vertical neighbours count. In the following diagram\nthe stones which matter are marked \"O\" and the stones that don't are\nmarked \"I\" (ignored).  Empty spaces represent empty intersections.\n\n```text\n+----+\n|IOOI|\n|O  O|\n|O OI|\n|IOI |\n+----+\n```\n\nTo be more precise an empty intersection is part of a player's territory\nif all of its neighbours are either stones of that player or empty\nintersections that are part of that player's territory.\n\nFor more information see\n[wikipedia](https://en.wikipedia.org/wiki/Go_%28game%29) or [Sensei's\nLibrary](http://senseis.xmp.net/).\n\n", "code": "go_counting.clj\n(ns go-counting)\n\n(defn valid-pos? [grid [x y]]\n  (and (>= x 0) (>= y 0) (< y (count grid)) (< x (count (first grid)))))\n\n(defn neighbors [grid [x y]]\n  (filter #(valid-pos? grid %)\n          [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]]))\n\n(defn dfs [grid visited [x y] player]\n  (if (or (contains? visited [x y]) (not (valid-pos? grid [x y])) (not= (get-in grid [y x]) player))\n    visited\n    (reduce #(dfs grid %1 %2 player) (conj visited [x y]) (neighbors grid [x y]))))\n\n(defn find-territory [grid [x y]]\n  (let [player (get-in grid [y x])]\n    (if (or (= player :black) (= player :white))\n      nil\n      (let [visited (dfs grid #{} [x y] player)]\n        (if (empty? visited)\n          nil\n          {:owner (if (= player :empty) :none player) :territory visited})))))\n\n(defn territory [grid [x y]]\n  (find-territory grid [x y]))\n\n(defn territories [grid]\n  (reduce (fn [acc pos]\n            (let [t (find-territory grid pos)]\n              (if t\n                (update-in acc [(:owner t)] #(into %1 (:territory t)))\n                acc)))\n          {:black #{} :white #{} :none #{}}\n          (for [y (range (count grid))\n                x (range (count (first grid)))]\n            [x y])))\n", "test-output": "test_output.txt\n\nlein test go-counting-test\n\nlein test :only go-counting-test/territories\n\nFAIL in (territories) (go_counting_test.clj:27)\nexpected: (= (g/territories [\" \"]) {:black-territory #{}, :white-territory #{}, :null-territory #{[0 0]}})\n  actual: (not (= {:black #{}, :white #{}, :none #{}, \\space ([0 0])} {:black-territory #{}, :white-territory #{}, :null-territory #{[0 0]}}))\n\nlein test :only go-counting-test/territories\n\nFAIL in (territories) (go_counting_test.clj:31)\nexpected: (= (g/territories [\" BW \" \" BW \"]) {:black-territory #{[0 0] [0 1]}, :white-territory #{[3 0] [3 1]}, :null-territory #{}})\n  actual: (not (= {:black #{}, :white #{}, :none #{}, \\space ([3 1] [3 0] [0 1] [0 0] [3 1] [3 0] [0 1] [0 0]), \\B ([1 1] [1 0] [1 1] [1 0]), \\W ([2 1] [2 0] [2 1] [2 0])} {:black-territory #{[0 0] [0 1]}, :white-territory #{[3 0] [3 1]}, :null-territory #{}}))\n\nlein test :only go-counting-test/territories\n\nFAIL in (territories) (go_counting_test.clj:35)\nexpected: (= (g/territories [\" B \"]) {:black-territory #{[0 0] [2 0]}, :white-territory #{}, :null-territory #{}})\n  actual: (not (= {:black #{}, :white #{}, :none #{}, \\space ([2 0] [0 0]), \\B ([1 0])} {:black-territory #{[0 0] [2 0]}, :white-territory #{}, :null-territory #{}}))\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:13)\nexpected: (= (g/territory example [0 1]) {:stones #{[0 0] [1 0] [0 1]}, :owner :black})\n  actual: (not (= {:owner \\space, :territory #{[0 0] [1 0] [0 1]}} {:stones #{[0 0] [1 0] [0 1]}, :owner :black}))\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:15)\nexpected: (= (g/territory example [2 3]) {:stones #{[2 3]}, :owner :white})\n  actual: (not (= {:owner \\space, :territory #{[2 3]}} {:stones #{[2 3]}, :owner :white}))\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:17)\nexpected: (= (g/territory example [1 4]) {:stones #{[1 4] [0 3] [0 4]}, :owner nil})\n  actual: (not (= {:owner \\space, :territory #{[1 4] [0 3] [0 4]}} {:stones #{[1 4] [0 3] [0 4]}, :owner nil}))\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:19)\nexpected: (= (g/territory example [1 1]) {:stones #{}, :owner nil})\n  actual: (not (= {:owner \\B, :territory #{[1 1]}} {:stones #{}, :owner nil}))\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:21)\nexpected: (thrown? Throwable (g/territory example [-1 1]))\n  actual: nil\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:22)\nexpected: (thrown? Throwable (g/territory example [5 1]))\n  actual: nil\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:23)\nexpected: (thrown? Throwable (g/territory example [1 -1]))\n  actual: nil\n\nlein test :only go-counting-test/territory\n\nFAIL in (territory) (go_counting_test.clj:24)\nexpected: (thrown? Throwable (g/territory example [1 5]))\n  actual: nil\n\nRan 2 tests containing 11 assertions.\n11 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "grade-school", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 4585, "instructions": "instructions.md\n# Instructions\n\nGiven students' names along with the grade that they are in, create a roster\nfor the school.\n\nIn the end, you should be able to:\n\n- Add a student's name to the roster for a grade\n  - \"Add Jim to grade 2.\"\n  - \"OK.\"\n- Get a list of all students enrolled in a grade\n  - \"Which students are in grade 2?\"\n  - \"We've only got Jim just now.\"\n- Get a sorted list of all students in all grades.  Grades should sort\n  as 1, 2, 3, etc., and students within a grade should be sorted\n  alphabetically by name.\n  - \"Who is enrolled in school right now?\"\n  - \"Let me think. We have\n  Anna, Barb, and Charlie in grade 1,\n  Alex, Peter, and Zoe in grade 2\n  and Jim in grade 5.\n  So the answer is: Anna, Barb, Charlie, Alex, Peter, Zoe and Jim\"\n\nNote that all our students only have one name.  (It's a small town, what\ndo you want?)\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these\nare some additional things you could try:\n\n- If you're working in a language with mutable data structures and your\n  implementation allows outside code to mutate the school's internal DB\n  directly, see if you can prevent this. Feel free to introduce additional\n  tests.\n\nThen please share your thoughts in a comment on the submission. Did this\nexperiment make the code better? Worse? Did you learn anything from it?\n\n", "code": "grade_school.clj\n(ns grade-school)\n\n(defn grade [school grade]\n    (sort (get school grade [])))\n\n(defn add [school name grade]\n    (update school grade (fnil (fn [students] (->> students (conj name) sort)) []) name))\n(defn sorted [school]\n    (into {}\n          (map (fn [[grade students]] [grade (sort students)]))\n          (sort-by key school)))\n", "test-output": "test_output.txt\n\nlein test grade-school-test\n\nlein test :only grade-school-test/add-students-to-different-grades\n\nERROR in (add-students-to-different-grades) (AFn.java:429)\nexpected: (= {3 [\"Chelsea\"], 7 [\"Logan\"]} (-> db (grade-school/add \"Chelsea\" 3) (grade-school/add \"Logan\" 7)))\n  actual: clojure.lang.ArityException: Wrong number of args (2) passed to: grade-school/add/fn--437\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:36)\n    clojure.core$fnil$fn__6883.invoke (core.clj:6567)\n    clojure.core$update.invokeStatic (core.clj:6198)\n    clojure.core$update.invoke (core.clj:6188)\n    grade_school$add.invokeStatic (grade_school.clj:7)\n    grade_school$add.invoke (grade_school.clj:6)\n    grade_school_test$fn__461.invokeStatic (grade_school_test.clj:20)\n    grade_school_test/fn (grade_school_test.clj:17)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357.invoke (form-init4037884982940261066.clj:1)\n    user$eval224.invokeStatic (form-init4037884982940261066.clj:1)\n    user$eval224.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only grade-school-test/add-student\n\nERROR in (add-student) (AFn.java:429)\nexpected: (= {2 [\"Aimee\"]} (grade-school/add db \"Aimee\" 2))\n  actual: clojure.lang.ArityException: Wrong number of args (2) passed to: grade-school/add/fn--437\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:36)\n    clojure.core$fnil$fn__6883.invoke (core.clj:6567)\n    clojure.core$update.invokeStatic (core.clj:6198)\n    clojure.core$update.invoke (core.clj:6188)\n    grade_school$add.invokeStatic (grade_school.clj:7)\n    grade_school$add.invoke (grade_school.clj:6)\n    grade_school_test$fn__451.invokeStatic (grade_school_test.clj:8)\n    grade_school_test/fn (grade_school_test.clj:7)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357.invoke (form-init4037884982940261066.clj:1)\n    user$eval224.invokeStatic (form-init4037884982940261066.clj:1)\n    user$eval224.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only grade-school-test/sorted-grade-school\n\nERROR in (sorted-grade-school) (AFn.java:429)\nexpected: (= (sorted-map 3 [\"Kyle\"] 4 [\"Christopher\" \"Jennifer\"] 6 [\"Kareem\"]) (-> db (grade-school/add \"Jennifer\" 4) (grade-school/add \"Kareem\" 6) (grade-school/add \"Christopher\" 4) (grade-school/add \"Kyle\" 3) (grade-school/sorted)))\n  actual: clojure.lang.ArityException: Wrong number of args (2) passed to: grade-school/add/fn--437\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:36)\n    clojure.core$fnil$fn__6883.invoke (core.clj:6567)\n    clojure.core$update.invokeStatic (core.clj:6198)\n    clojure.core$update.invoke (core.clj:6188)\n    grade_school$add.invokeStatic (grade_school.clj:7)\n    grade_school$add.invoke (grade_school.clj:6)\n    grade_school_test$fn__476.invokeStatic (grade_school_test.clj:39)\n    grade_school_test/fn (grade_school_test.clj:34)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357.invoke (form-init4037884982940261066.clj:1)\n    user$eval224.invokeStatic (form-init4037884982940261066.clj:1)\n    user$eval224.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only grade-school-test/get-students-in-a-grade\n\nERROR in (get-students-in-a-grade) (AFn.java:429)\nexpected: (= [\"Franklin\" \"Bradley\"] (-> db (grade-school/add \"Franklin\" 5) (grade-school/add \"Bradley\" 5) (grade-school/add \"Jeff\" 1) (grade-school/grade 5)))\n  actual: clojure.lang.ArityException: Wrong number of args (2) passed to: grade-school/add/fn--437\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:36)\n    clojure.core$fnil$fn__6883.invoke (core.clj:6567)\n    clojure.core$update.invokeStatic (core.clj:6198)\n    clojure.core$update.invoke (core.clj:6188)\n    grade_school$add.invokeStatic (grade_school.clj:7)\n    grade_school$add.invoke (grade_school.clj:6)\n    grade_school_test$fn__466.invokeStatic (grade_school_test.clj:26)\n    grade_school_test/fn (grade_school_test.clj:23)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357.invoke (form-init4037884982940261066.clj:1)\n    user$eval224.invokeStatic (form-init4037884982940261066.clj:1)\n    user$eval224.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only grade-school-test/add-more-students-in-same-class\n\nERROR in (add-more-students-in-same-class) (AFn.java:429)\nexpected: (= {2 [\"James\" \"Blair\" \"Paul\"]} (-> db (grade-school/add \"James\" 2) (grade-school/add \"Blair\" 2) (grade-school/add \"Paul\" 2)))\n  actual: clojure.lang.ArityException: Wrong number of args (2) passed to: grade-school/add/fn--437\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:36)\n    clojure.core$fnil$fn__6883.invoke (core.clj:6567)\n    clojure.core$update.invokeStatic (core.clj:6198)\n    clojure.core$update.invoke (core.clj:6188)\n    grade_school$add.invokeStatic (grade_school.clj:7)\n    grade_school$add.invoke (grade_school.clj:6)\n    grade_school_test$fn__456.invokeStatic (grade_school_test.clj:13)\n    grade_school_test/fn (grade_school_test.clj:10)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357.invoke (form-init4037884982940261066.clj:1)\n    user$eval224.invokeStatic (form-init4037884982940261066.clj:1)\n    user$eval224.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only grade-school-test/sorted-grade_school-keys-sorted\n\nERROR in (sorted-grade_school-keys-sorted) (AFn.java:429)\nexpected: (= [3 4 6] (-> db (grade-school/add \"Jennifer\" 4) (grade-school/add \"Kareem\" 6) (grade-school/add \"Christopher\" 4) (grade-school/add \"Kyle\" 3) (grade-school/sorted) (keys)))\n  actual: clojure.lang.ArityException: Wrong number of args (2) passed to: grade-school/add/fn--437\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:36)\n    clojure.core$fnil$fn__6883.invoke (core.clj:6567)\n    clojure.core$update.invokeStatic (core.clj:6198)\n    clojure.core$update.invoke (core.clj:6188)\n    grade_school$add.invokeStatic (grade_school.clj:7)\n    grade_school$add.invoke (grade_school.clj:6)\n    grade_school_test$fn__481.invokeStatic (grade_school_test.clj:48)\n    grade_school_test/fn (grade_school_test.clj:45)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init4037884982940261066.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init4037884982940261066.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init4037884982940261066.clj:1)\n    user$eval224$fn__357.invoke (form-init4037884982940261066.clj:1)\n    user$eval224.invokeStatic (form-init4037884982940261066.clj:1)\n    user$eval224.invoke (form-init4037884982940261066.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 7 tests containing 7 assertions.\n0 failures, 6 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "grains", "response": "The coder failed the test due to incorrect calculations in the `square` and `total` functions. In the `square` function, the result is off by one. In the `total` function, the result is out of range for the long data type.\n\nreason: logic\n", "reason": "logic", "tokens": 4728, "instructions": "instructions.md\n# Instructions\n\nCalculate the number of grains of wheat on a chessboard given that the number\non each square doubles.\n\nThere once was a wise servant who saved the life of a prince. The king\npromised to pay whatever the servant could dream up. Knowing that the\nking loved chess, the servant told the king he would like to have grains\nof wheat. One grain on the first square of a chess board, with the number\nof grains doubling on each successive square.\n\nThere are 64 squares on a chessboard (where square 1 has one grain, square 2 has two grains, and so on).\n\nWrite code that shows:\n- how many grains were on a given square, and\n- the total number of grains on the chessboard\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these\nare some additional things you could try:\n\n- Optimize for speed.\n- Optimize for readability.\n\nThen please share your thoughts in a comment on the submission. Did this\nexperiment make the code better? Worse? Did you learn anything from it?\n\n", "code": "grains.clj\n(ns grains)\n\n(defn square [n]\n    (long (Math/pow 2 (dec n)))\n)\n\n(defn total []\n    (dec (long (Math/pow 2 64)))\n)\n", "test-output": "test_output.txt\n\nlein test grains-test\n\nlein test :only grains-test/square-64\n\nFAIL in (square-64) (grains_test.clj:24)\nexpected: (= 9223372036854775808N (grains/square 64))\n  actual: (not (= 9223372036854775808N 9223372036854775807))\n\nlein test :only grains-test/total-grains\n\nERROR in (total-grains) (RT.java:1307)\nexpected: (= 18446744073709551615N (grains/total))\n  actual: java.lang.IllegalArgumentException: Value out of range for long: 1.8446744073709552E19\n at clojure.lang.RT.longCast (RT.java:1307)\n    grains$total.invokeStatic (grains.clj:8)\n    grains$total.invoke (grains.clj:7)\n    grains_test$fn__477.invokeStatic (grains_test.clj:27)\n    grains_test/fn (grains_test.clj:26)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12431282175543107183.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12431282175543107183.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12431282175543107183.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12431282175543107183.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12431282175543107183.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12431282175543107183.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12431282175543107183.clj:1)\n    user$eval224$fn__357.invoke (form-init12431282175543107183.clj:1)\n    user$eval224.invokeStatic (form-init12431282175543107183.clj:1)\n    user$eval224.invoke (form-init12431282175543107183.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 8 tests containing 8 assertions.\n1 failures, 1 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "hamming", "response": "The coder failed the test due to a syntax error in their code. The error occurred while reading the source code at line 7, column 1.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4753, "instructions": "instructions.md\n# Instructions\n\nCalculate the Hamming Distance between two DNA strands.\n\nYour body is made up of cells that contain DNA. Those cells regularly wear out and need replacing, which they achieve by dividing into daughter cells. In fact, the average human body experiences about 10 quadrillion cell divisions in a lifetime!\n\nWhen cells divide, their DNA replicates too. Sometimes during this process mistakes happen and single pieces of DNA get encoded with the incorrect information. If we compare two strands of DNA and count the differences between them we can see how many mistakes occurred. This is known as the \"Hamming Distance\".\n\nWe read DNA using the letters C,A,G and T. Two strands might look like this:\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThey have 7 differences, and therefore the Hamming Distance is 7.\n\nThe Hamming Distance is useful for lots of things in science, not just biology, so it's a nice phrase to be familiar with :)\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length, so\nan attempt to calculate it between sequences of different lengths should\nnot work. The general handling of this situation (e.g., raising an\nexception vs returning a special value) may differ between languages.\n\n", "code": "hamming.clj\n(ns hamming)\n\n(defn distance [strand1 strand2]\n  (if (not= (count strand1) (count strand2))\n    nil\n    (count (filter true? (map not= strand1 strand2))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (hamming.clj:7:1).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat hamming_test$eval422$loading__6706__auto____423.invoke(hamming_test.clj:1)\n\tat hamming_test$eval422.invokeStatic(hamming_test.clj:1)\n\tat hamming_test$eval422.invoke(hamming_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init9866033306154785485.clj:1)\n\tat user$eval224.invoke(form-init9866033306154785485.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: EOF while reading, starting at line 3\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1405)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "hello-world", "tokens": 1917, "instructions": "instructions.md\n# Instructions\n\nThe classical introductory exercise. Just say \"Hello, World!\".\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is\nthe traditional first program for beginning programming in a new language\nor environment.\n\nThe objectives are simple:\n\n- Write a function that returns the string \"Hello, World!\".\n- Run the test suite and make sure that it succeeds.\n- Submit your solution and check it at the website.\n\nIf everything goes well, you will be ready to fetch your first real exercise.\n\ninstructions.append.md\n# Instructions append\n\n## Project Structure\n\nClojure exercises in exercism support the two most common tools for dependency management and testing, [leiningen](http://leiningen.org/) and the [Clojure CLI](https://clojure.org/guides/deps_and_cli).\n\nYou will find a test file named `hello_world_test.clj` inside `test` directory.\nWrite your code in `src/hello_world.clj`. It should use the namespace `hello-world` so that tests can pick it up.\n\n### Running tests using the Clojure CLI\n\n```\n$ clj -X:test\n```\n\n### Running tests using Leiningen\n\n```\n$ lein test\n\nlein test hello-world-test\n\nRan 3 tests containing 3 assertions.\n0 failures, 0 errors.\n```\n\nThen submit the exercise using:\n\n```\n$ exercism submit src/hello_world.clj\n```\n\nFor more detailed instructions and learning resources refer [exercism's clojure language page](http://exercism.org/languages/clojure).\n\n", "code": "hello_world.clj\n(ns hello-world)\n\n(defn hello []\n  \"Hello, World!\")\n", "test-output": "test_output.txt\n\nlein test hello-world-test\n\nRan 1 tests containing 1 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "hexadecimal", "response": "The coder failed the test because they used the `return` keyword, which is not valid in Clojure. They should replace it with the appropriate value they want to return in that branch of the conditional expression.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4152, "instructions": "instructions.md\n# Instructions\n\nConvert a hexadecimal number, represented as a string (e.g. \"10af8c\"), to its decimal equivalent using first principles (i.e. no, you may not use built-in or external libraries to accomplish the conversion).\n\nOn the web we use hexadecimal to represent colors, e.g. green: 008000,\nteal: 008080, navy: 000080).\n\nThe program should handle invalid hexadecimal strings.\n\n", "code": "hexadecimal.clj\n(ns hexadecimal)\n\n(defn hex-to-int [hex-string]\n  (let [hex-digits {\"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"a\" 10 \"b\" 11 \"c\" 12 \"d\" 13 \"e\" 14 \"f\" 15}]\n    (loop [hex-chars (seq hex-string) decimal 0]\n      (if (empty? hex-chars)\n        decimal\n        (let [hex-char (clojure.string/lower-case (first hex-chars))\n              hex-value (hex-digits hex-char)]\n          (if (nil? hex-value)\n            (return 0)\n            (recur (next hex-chars) (+ (* decimal 16) hex-value))))))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (hexadecimal.clj:11:13).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3820)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2829)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6436)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2837)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6436)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6436)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:596)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler.eval(Compiler.java:7180)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat hexadecimal_test$eval422$loading__6706__auto____423.invoke(hexadecimal_test.clj:1)\n\tat hexadecimal_test$eval422.invokeStatic(hexadecimal_test.clj:1)\n\tat hexadecimal_test$eval422.invoke(hexadecimal_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init11499029195169178883.clj:1)\n\tat user$eval224.invoke(form-init11499029195169178883.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unable to resolve symbol: return in this context\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7413)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 117 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "isbn-verifier", "response": "The coder failed the test because their implementation doesn't correctly handle cases where the check digit is a character other than 'X'. The code doesn't account for invalid characters in the check digit position, resulting in false positives for some invalid ISBNs.\n\nreason: logic\n", "reason": "logic", "tokens": 5002, "instructions": "instructions.md\n# Instructions\n\nThe [ISBN-10 verification process](https://en.wikipedia.org/wiki/International_Standard_Book_Number) is used to validate book identification\nnumbers. These normally contain dashes and look like: `3-598-21508-8`\n\n## ISBN\n\nThe ISBN-10 format is 9 digits (0 to 9) plus one check character (either a digit or an X only). In the case the check character is an X, this represents the value '10'. These may be communicated with or without hyphens, and can be checked for their validity by the following formula:\n\n```\n(x1 * 10 + x2 * 9 + x3 * 8 + x4 * 7 + x5 * 6 + x6 * 5 + x7 * 4 + x8 * 3 + x9 * 2 + x10 * 1) mod 11 == 0\n```\n\nIf the result is 0, then it is a valid ISBN-10, otherwise it is invalid.\n\n## Example\n\nLet's take the ISBN-10 `3-598-21508-8`. We plug it in to the formula, and get:\n```\n(3 * 10 + 5 * 9 + 9 * 8 + 8 * 7 + 2 * 6 + 1 * 5 + 5 * 4 + 0 * 3 + 8 * 2 + 8 * 1) mod 11 == 0\n```\n\nSince the result is 0, this proves that our ISBN is valid.\n\n## Task\n\nGiven a string the program should check if the provided string is a valid ISBN-10.\nPutting this into place requires some thinking about preprocessing/parsing of the string prior to calculating the check digit for the ISBN.\n\nThe program should be able to verify ISBN-10 both with and without separating dashes.\n\n\n## Caveats\n\nConverting from strings to numbers can be tricky in certain languages.\nNow, it's even trickier since the check digit of an ISBN-10 may be 'X' (representing '10'). For instance `3-598-21507-X` is a valid ISBN-10.\n\n## Bonus tasks\n\n* Generate a valid ISBN-13 from the input ISBN-10 (and maybe verify it again with a derived verifier).\n\n* Generate valid ISBN, maybe even from a given starting ISBN.\n\n", "code": "isbn_verifier.clj\n(ns isbn-verifier)\n\n(defn isbn? [isbn]\n  (let [cleaned-isbn (clojure.string/replace isbn #\"-\" \"\")\n        valid-length? (= 10 (count cleaned-isbn))]\n    (if valid-length?\n      (let [digits (map #(if (= % \\X) 10 (Character/digit % 10)) cleaned-isbn)\n            valid-X? (or (not (some #{\\X} (butlast digits))) (= (last digits) \\X))\n            weighted-sum (reduce + (map * digits (range 10 0 -1)))]\n        (and valid-X? (= 0 (mod weighted-sum 11))))\n      false)))\n", "test-output": "test_output.txt\n\nlein test isbn-verifier-test\n\nlein test :only isbn-verifier-test/X-is-only-valid-as-a-check-digit\n\nFAIL in (X-is-only-valid-as-a-check-digit) (isbn_verifier_test.clj:21)\nexpected: (= false (isbn? \"3-598-2X507-9\"))\n  actual: (not (= false true))\n\nlein test :only isbn-verifier-test/check-digit-is-a-character-other-than-X\n\nFAIL in (check-digit-is-a-character-other-than-X) (isbn_verifier_test.clj:15)\nexpected: (= false (isbn? \"3-598-21507-A\"))\n  actual: (not (= false true))\n\nRan 14 tests containing 14 assertions.\n2 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "isogram", "response": "The coder failed the test because there was a syntax error in the code. The error occurred while reading the source at line 9, column 1, causing the test suite to throw an exception.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4478, "instructions": "instructions.md\n# Instructions\n\nDetermine if a word or phrase is an isogram.\n\nAn isogram (also known as a \"nonpattern word\") is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times.\n\nExamples of isograms:\n\n- lumberjacks\n- background\n- downstream\n- six-year-old\n\nThe word *isograms*, however, is not an isogram, because the s repeats.\n\n", "code": "isogram.clj\n(ns isogram\n  (:require [clojure.string :as str]))\n\n(defn isogram? [s]\n  (let [normalized (->> s\n                        (clojure.string/lower-case)\n                        (filter #(contains? (set \"abcdefghijklmnopqrstuvwxyz\") %)))]\n    (= (count normalized) (count (distinct normalized))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (isogram.clj:9:1).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat isogram_test$eval422$loading__6706__auto____423.invoke(isogram_test.clj:1)\n\tat isogram_test$eval422.invokeStatic(isogram_test.clj:1)\n\tat isogram_test$eval422.invoke(isogram_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init14521367693232456838.clj:1)\n\tat user$eval224.invoke(form-init14521367693232456838.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: EOF while reading, starting at line 4\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1405)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "kindergarten-garden", "response": "The coder failed the test because they didn't provide the correct number of arguments when calling the `garden` function in the test cases. The test cases are only passing one argument (the diagram), but the function is expecting two arguments (diagram and students).\n\nreason: logic\n", "reason": "logic", "tokens": 5916, "instructions": "instructions.md\n# Instructions\n\nGiven a diagram, determine which plants each child in the kindergarten class is\nresponsible for.\n\nThe kindergarten class is learning about growing plants. The teacher\nthought it would be a good idea to give them actual seeds, plant them in\nactual dirt, and grow actual plants.\n\nThey've chosen to grow grass, clover, radishes, and violets.\n\nTo this end, the children have put little cups along the window sills, and\nplanted one type of plant in each cup, choosing randomly from the available\ntypes of seeds.\n\n```text\n[window][window][window]\n........................ # each dot represents a cup\n........................\n```\n\nThere are 12 children in the class:\n\n- Alice, Bob, Charlie, David,\n- Eve, Fred, Ginny, Harriet,\n- Ileana, Joseph, Kincaid, and Larry.\n\nEach child gets 4 cups, two on each row. Their teacher assigns cups to\nthe children alphabetically by their names.\n\nThe following diagram represents Alice's plants:\n\n```text\n[window][window][window]\nVR......................\nRG......................\n```\n\nIn the first row, nearest the windows, she has a violet and a radish.  In the\nsecond row she has a radish and some grass.\n\nYour program will be given the plants from left-to-right starting with\nthe row nearest the windows. From this, it should be able to determine\nwhich plants belong to each student.\n\nFor example, if it's told that the garden looks like so:\n\n```text\n[window][window][window]\nVRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV\n```\n\nThen if asked for Alice's plants, it should provide:\n\n- Violets, radishes, violets, radishes\n\nWhile asking for Bob's plants would yield:\n\n- Clover, grass, clover, clover\n\n", "code": "kindergarten_garden.clj\n(ns kindergarten-garden)\n(def plant-names {\"V\" \"Violets\" \"R\" \"Radishes\" \"C\" \"Clover\" \"G\" \"Grass\"})\n(def students [\"Alice\" \"Bob\" \"Charlie\" \"David\" \"Eve\" \"Fred\" \"Ginny\" \"Harriet\" \"Ileana\" \"Joseph\" \"Kincaid\" \"Larry\"])\n\n(defn garden [diagram students]\n  (let [rows (clojure.string/split-lines diagram)\n        window-row (first rows)\n        away-row (second rows)\n        plants-for (fn [idx]\n                     (map (fn [plant-initial] (get plant-names plant-initial))\n                          [(get window-row (* idx 2)) (get window-row (inc (* idx 2)))\n                           (get away-row (* idx 2)) (get away-row (inc (* idx 2)))]))]\n    (into {} (map (fn [idx] [(get students idx) (plants-for idx)]) (range 0 (count students))))))\n", "test-output": "test_output.txt\n\nlein test kindergarten-garden-test\n\nlein test :only kindergarten-garden-test/surprise-garden-test\n\nFAIL in (surprise-garden-test) (kindergarten_garden_test.clj:40)\nexpected: (= [:violets :clover :radishes :violets] (:patricia surprise-garden))\n  actual: (not (= [:violets :clover :radishes :violets] nil))\n\nlein test :only kindergarten-garden-test/surprise-garden-test\n\nFAIL in (surprise-garden-test) (kindergarten_garden_test.clj:42)\nexpected: (= [:radishes :radishes :grass :clover] (:roger surprise-garden))\n  actual: (not (= [:radishes :radishes :grass :clover] nil))\n\nlein test :only kindergarten-garden-test/surprise-garden-test\n\nFAIL in (surprise-garden-test) (kindergarten_garden_test.clj:44)\nexpected: (= [:grass :violets :clover :grass] (:samantha surprise-garden))\n  actual: (not (= [:grass :violets :clover :grass] nil))\n\nlein test :only kindergarten-garden-test/surprise-garden-test\n\nFAIL in (surprise-garden-test) (kindergarten_garden_test.clj:46)\nexpected: (= [:radishes :grass :clover :violets] (:xander surprise-garden))\n  actual: (not (= [:radishes :grass :clover :violets] nil))\n\nlein test :only kindergarten-garden-test/small-garden-test\n\nERROR in (small-garden-test) (AFn.java:429)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: kindergarten-garden/garden\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    kindergarten_garden_test$fn__456.invokeStatic (kindergarten_garden_test.clj:12)\n    kindergarten_garden_test/fn (kindergarten_garden_test.clj:11)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357.invoke (form-init16967527543010494630.clj:1)\n    user$eval224.invokeStatic (form-init16967527543010494630.clj:1)\n    user$eval224.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only kindergarten-garden-test/medium-garden-test\n\nERROR in (medium-garden-test) (AFn.java:429)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: kindergarten-garden/garden\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    kindergarten_garden_test$fn__461.invokeStatic (kindergarten_garden_test.clj:16)\n    kindergarten_garden_test/fn (kindergarten_garden_test.clj:15)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357.invoke (form-init16967527543010494630.clj:1)\n    user$eval224.invokeStatic (form-init16967527543010494630.clj:1)\n    user$eval224.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only kindergarten-garden-test/garden-test\n\nERROR in (garden-test) (AFn.java:429)\nexpected: (= [:radishes :clover :grass :grass] (:alice (kindergarten-garden/garden \"RC\\nGG\")))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: kindergarten-garden/garden\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    kindergarten_garden_test$fn__447$fn__448.invoke (kindergarten_garden_test.clj:7)\n    kindergarten_garden_test$fn__447.invokeStatic (kindergarten_garden_test.clj:6)\n    kindergarten_garden_test/fn (kindergarten_garden_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357.invoke (form-init16967527543010494630.clj:1)\n    user$eval224.invokeStatic (form-init16967527543010494630.clj:1)\n    user$eval224.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only kindergarten-garden-test/garden-test\n\nERROR in (garden-test) (AFn.java:429)\nexpected: (= [:violets :clover :radishes :clover] (:alice (kindergarten-garden/garden \"VC\\nRC\")))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: kindergarten-garden/garden\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    kindergarten_garden_test$fn__447.invokeStatic (kindergarten_garden_test.clj:9)\n    kindergarten_garden_test/fn (kindergarten_garden_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357.invoke (form-init16967527543010494630.clj:1)\n    user$eval224.invokeStatic (form-init16967527543010494630.clj:1)\n    user$eval224.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only kindergarten-garden-test/full-garden-test\n\nERROR in (full-garden-test) (AFn.java:429)\nUncaught exception, not in assertion.\nexpected: nil\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: kindergarten-garden/garden\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    kindergarten_garden_test$fn__470.invokeStatic (kindergarten_garden_test.clj:22)\n    kindergarten_garden_test/fn (kindergarten_garden_test.clj:20)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init16967527543010494630.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init16967527543010494630.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init16967527543010494630.clj:1)\n    user$eval224$fn__357.invoke (form-init16967527543010494630.clj:1)\n    user$eval224.invokeStatic (form-init16967527543010494630.clj:1)\n    user$eval224.invoke (form-init16967527543010494630.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 5 tests containing 9 assertions.\n4 failures, 5 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "largest-series-product", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 4425, "instructions": "instructions.md\n# Instructions\n\nYour task is to look for patterns in the long sequence of digits in the encrypted signal.\n\nThe technique you're going to use here is called the largest series product.\n\nLet's define a few terms, first.\n\n- **input**: the sequence of digits that you need to analyze\n- **series**: a sequence of adjacent digits (those that are next to each other) that is contained within the input\n- **span**: how many digits long each series is\n- **product**: what you get when you multiply numbers together\n\nLet's work through an example, with the input `\"63915\"`.\n\n- To form a series, take adjacent digits in the original input.\n- If you are working with a span of `3`, there will be three possible series:\n  - `\"639\"`\n  - `\"391\"`\n  - `\"915\"`\n- Then we need to calculate the product of each series:\n  - The product of the series `\"639\"` is 162 (`6 \u00d7 3 \u00d7 9 = 162`)\n  - The product of the series `\"391\"` is 27 (`3 \u00d7 9 \u00d7 1 = 27`)\n  - The product of the series `\"915\"` is 45 (`9 \u00d7 1 \u00d7 5 = 45`)\n- 162 is bigger than both 27 and 45, so the largest series product of `\"63915\"` is from the series `\"639\"`.\n  So the answer is **162**.\n\nintroduction.md\n# Introduction\n\nYou work for a government agency that has intercepted a series of encrypted communication signals from a group of bank robbers.\nThe signals contain a long sequence of digits.\nYour team needs to use various digital signal processing techniques to analyze the signals and identify any patterns that may indicate the planning of a heist.\n\n", "code": "largest_series_product.clj\n(ns largest-series-product)\n\n(defn str-to-digits [s]\n  (map #(Character/digit % 10) s))\n(defn largest-product [input span]\n  (let [digits (str-to-digits input)]\n    (if (<= span 0)\n      1\n      (apply max\n             (map #(reduce * %)\n                  (map (partial map #(Character/digit % 10))\n                       (partition span 1 digits)))))))", "test-output": "test_output.txt\n\nlein test largest-series-product-test\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan find the largest product of 2 with numbers in order\nexpected: (= 72 (lsp/largest-product 2 \"0123456789\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__452.invoke (largest_series_product_test.clj:7)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:6)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan find the largest product of 2\nexpected: (= 48 (lsp/largest-product 2 \"576802143\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__456.invoke (largest_series_product_test.clj:9)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:8)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\nfinds the largest product if span equals length\nexpected: (= 18 (lsp/largest-product 2 \"29\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__460.invoke (largest_series_product_test.clj:11)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:10)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan find the largest product of 3 with numbers in order\nexpected: (= 504 (lsp/largest-product 3 \"0123456789\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__464.invoke (largest_series_product_test.clj:13)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:12)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan find the largest product of 3\nexpected: (= 270 (lsp/largest-product 3 \"1027839564\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__468.invoke (largest_series_product_test.clj:15)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:14)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan find the largest product of 5 with numbers in order\nexpected: (= 15120 (lsp/largest-product 5 \"0123456789\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__472.invoke (largest_series_product_test.clj:17)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:16)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan get the largest product of a big number\nexpected: (= 23520 (let [ds \"73167176531330624919225119674426574742355349194934\"] (lsp/largest-product 6 ds)))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__476.invoke (largest_series_product_test.clj:21)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:18)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan get the largest product of a big number II\nexpected: (= 28350 (let [ds \"52677741234314237566414902593461595376319419139427\"] (lsp/largest-product 6 ds)))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__480.invoke (largest_series_product_test.clj:25)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:22)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\ncan get the largest product of a big number (Project Euler)\nexpected: (= 23514624000 (let [ds \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\"] (lsp/largest-product 13 ds)))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__484.invoke (largest_series_product_test.clj:29)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:26)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\nreports zero if the only digits are zero\nexpected: (= 0 (lsp/largest-product 2 \"0000\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__488.invoke (largest_series_product_test.clj:31)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:30)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only largest-series-product-test/largest-series-tests\n\nERROR in (largest-series-tests) (Numbers.java:255)\nreports zero if all spans include zero\nexpected: (= 0 (lsp/largest-product 3 \"99099\"))\n  actual: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\n at clojure.lang.Numbers.lte (Numbers.java:255)\n    clojure.lang.Numbers.lte (Numbers.java:3933)\n    largest_series_product$largest_product.invokeStatic (largest_series_product.clj:7)\n    largest_series_product$largest_product.invoke (largest_series_product.clj:5)\n    largest_series_product_test$fn__451$fn__492.invoke (largest_series_product_test.clj:33)\n    largest_series_product_test$fn__451.invokeStatic (largest_series_product_test.clj:32)\n    largest_series_product_test/fn (largest_series_product_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init2387028764623016555.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init2387028764623016555.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init2387028764623016555.clj:1)\n    user$eval224$fn__357.invoke (form-init2387028764623016555.clj:1)\n    user$eval224.invokeStatic (form-init2387028764623016555.clj:1)\n    user$eval224.invoke (form-init2387028764623016555.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 1 tests containing 15 assertions.\n0 failures, 11 errors.\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "leap", "tokens": 3873, "instructions": "instructions.md\n# Instructions\n\nGiven a year, report if it is a leap year.\n\nThe tricky thing here is that a leap year in the Gregorian calendar occurs:\n\n```text\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\n## Notes\n\nThough our exercise adopts some very simple rules, there is more to\nlearn!\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n", "code": "leap.clj\n(ns leap)\n\n(defn leap-year? [year]\n  (and (or (= 0 (mod year 4))\n           (and (= 0 (mod year 100))\n                (= 0 (mod year 400))))\n       (not (and (= 0 (mod year 100))\n                 (not (= 0 (mod year 400)))))))\n", "test-output": "test_output.txt\n\nlein test leap-test\n\nRan 9 tests containing 9 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "luhn", "response": "The coder failed the test due to a syntax error in their code. They accidentally duplicated a line that calculates the total sum of doubled-digits, causing an unmatched delimiter error.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4910, "instructions": "instructions.md\n# Instructions\n\nGiven a number determine whether or not it is valid per the Luhn formula.\n\nThe [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is\na simple checksum formula used to validate a variety of identification\nnumbers, such as credit card numbers and Canadian Social Insurance\nNumbers.\n\nThe task is to check if a given string is valid.\n\nValidating a Number\n------\n\nStrings of length 1 or less are not valid. Spaces are allowed in the input,\nbut they should be stripped before checking. All other non-digit characters\nare disallowed.\n\n## Example 1: valid credit card number\n\n```text\n4539 3195 0343 6467\n```\n\nThe first step of the Luhn algorithm is to double every second digit,\nstarting from the right. We will be doubling\n\n```text\n4_3_ 3_9_ 0_4_ 6_6_\n```\n\nIf doubling the number results in a number greater than 9 then subtract 9\nfrom the product. The results of our doubling:\n\n```text\n8569 6195 0383 3437\n```\n\nThen sum all of the digits:\n\n```text\n8+5+6+9+6+1+9+5+0+3+8+3+3+4+3+7 = 80\n```\n\nIf the sum is evenly divisible by 10, then the number is valid. This number is valid!\n\n## Example 2: invalid credit card number\n\n```text\n8273 1232 7352 0569\n```\n\nDouble the second digits, starting from the right\n\n```text\n7253 2262 5312 0539\n```\n\nSum the digits\n\n```text\n7+2+5+3+2+2+6+2+5+3+1+2+0+5+3+9 = 57\n```\n\n57 is not evenly divisible by 10, so this number is not valid.\n\n", "code": "luhn.clj\n(ns luhn)\n\n(defn valid? [number]\n  (let [cleaned-number (clojure.string/replace number #\"\\s\" \"\")\n        digits (map #(Character/digit % 10) cleaned-number)\n        valid-input? (and (>= (count cleaned-number) 2)\n                          (every? #(Character/isDigit %) cleaned-number))]\n    (if (not valid-input?)\n      false\n      (let [doubled-digits (map-indexed (fn [index digit]\n                                          (if (odd? index)\n                                            digit\n                                            (let [doubled (* 2 digit)]\n                                              (if (> doubled 9)\n                                                (- doubled 9)\n                                                doubled))))\n                                        (reverse digits))\n            total (reduce + doubled-digits)]\n            total (reduce + doubled-digits)]\n        (zero? (mod total 10))))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (luhn.clj:19:45).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat luhn_test$eval422$loading__6706__auto____423.invoke(luhn_test.clj:1)\n\tat luhn_test$eval422.invokeStatic(luhn_test.clj:1)\n\tat luhn_test$eval422.invoke(luhn_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init7115641846249681364.clj:1)\n\tat user$eval224.invoke(form-init7115641846249681364.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unmatched delimiter: ]\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1373)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "matching-brackets", "tokens": 1676, "instructions": "instructions.md\n# Instructions\n\nGiven a string containing brackets `[]`, braces `{}`, parentheses `()`,\nor any combination thereof, verify that any and all pairs are matched\nand nested correctly.\n\n", "code": "matching_brackets.clj\n(ns matching-brackets)\n\n(defn valid? [s]\n  (let [bracket-map { \\) \\(, \\] \\[, \\} \\{ }]\n    (loop [chars (seq s) stack []]\n      (if-let [c (first chars)]\n        (cond\n          (contains? bracket-map c)\n            (if (= (peek stack) (bracket-map c))\n              (recur (next chars) (pop stack))\n              false)\n          (contains? (set (vals bracket-map)) c)\n            (recur (next chars) (conj stack c))\n          :else\n            (recur (next chars) stack))\n        (empty? stack)))))\n", "test-output": "test_output.txt\n\nlein test matching-brackets-test\n\nRan 13 tests containing 13 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "meetup", "response": "The coder failed the test because there is a syntax error in their code. They have an extra closing parenthesis at the end of the `nth-day-of-week` function definition, and the `day-of-week-map` is defined inside that function instead of being outside.\n\nreason: syntax\n", "reason": "syntax", "tokens": 6381, "instructions": "instructions.md\n# Instructions\n\nCalculate the date of meetups.\n\nTypically meetups happen on the same day of the week.  In this exercise, you\nwill take a description of a meetup date, and return the actual meetup date.\n\nExamples of general descriptions are:\n\n- The first Monday of January 2017\n- The third Tuesday of January 2017\n- The wednesteenth of January 2017\n- The last Thursday of January 2017\n\nThe descriptors you are expected to parse are:\nfirst, second, third, fourth, fifth, last, monteenth, tuesteenth, wednesteenth,\nthursteenth, friteenth, saturteenth, sunteenth\n\nNote that \"monteenth\", \"tuesteenth\", etc are all made up words. There was a\nmeetup whose members realized that there are exactly 7 numbered days in a month\nthat end in '-teenth'. Therefore, one is guaranteed that each day of the week\n(Monday, Tuesday, ...) will have exactly one date that is named with '-teenth'\nin every month.\n\nGiven examples of a meetup dates, each containing a month, day, year, and\ndescriptor calculate the date of the actual meetup.  For example, if given\n\"The first Monday of January 2017\", the correct meetup date is 2017/1/2.\n\n", "code": "meetup.clj\n(ns meetup)\n(:require [clojure.string :as str]\n          [clojure.tools.logging :as log])\n(import 'java.time.LocalDate\n        'java.time.DayOfWeek)\n\n(defn day-of-week [year month day]\n  (.getValue (DayOfWeek/from (.of LocalDate year month day))))\n(defn nth-day-of-week [year month day-of-week n]\n  (let [start-date (.of LocalDate year month 1)\n        start-day (.getValue (DayOfWeek/from start-date))\n        day-delta (if (< start-day day-of-week)\n                    (- day-of-week start-day)\n                    (- (+ 7 day-of-week) start-day))]\n    (.plusDays start-date (+ day-delta (* 7 (dec n))))))\n  (let [day-of-week-map {\"mon\" 1 \"tues\" 2 \"wednes\" 3 \"thurs\" 4 \"fri\" 5 \"satur\" 6 \"sun\" 7}\n(defn teenth-day-of-week [year month day-of-week]\n  (nth-day-of-week year month day-of-week 2))\n\n(defn meetup [year month descriptor]\n  (let [day-of-week-map {\"mon\" 1 \"tues\" 2 \"wednes\" 3 \"thurs\" 4 \"fri\" 5 \"satur\" 6 \"sun\" 7}\n        descriptor-parts (str/split descriptor #\" \")\n        day-of-week (day-of-week-map (first descriptor-parts))\n        descriptor-type (second descriptor-parts)]\n    (cond\n      (= descriptor-type \"teenth\") (teenth-day-of-week year month day-of-week)\n      (= descriptor-type \"last\") (nth-day-of-week year month day-of-week 5)\n      :else (nth-day-of-week year month day-of-week (Integer/parseInt descriptor-type)))))", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (meetup.clj:2:1).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$VectorExpr.parse(Compiler.java:3260)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6791)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3888)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.eval(Compiler.java:7173)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat meetup_test$eval422$loading__6706__auto____423.invoke(meetup_test.clj:1)\n\tat meetup_test$eval422.invokeStatic(meetup_test.clj:1)\n\tat meetup_test$eval422.invoke(meetup_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init12083170715961801275.clj:1)\n\tat user$eval224.invoke(form-init12083170715961801275.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.ClassNotFoundException: clojure.string\n\tat java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:476)\n\tat clojure.lang.DynamicClassLoader.findClass(DynamicClassLoader.java:69)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:594)\n\tat clojure.lang.DynamicClassLoader.loadClass(DynamicClassLoader.java:77)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:527)\n\tat java.base/java.lang.Class.forName0(Native Method)\n\tat java.base/java.lang.Class.forName(Class.java:398)\n\tat clojure.lang.RT.classForName(RT.java:2207)\n\tat clojure.lang.RT.classForName(RT.java:2216)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7394)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 84 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "minesweeper", "response": "The coder failed the test because their implementation of the 'draw' function is incorrect. The 'count' function\n", "reason": "r failed the test because their implementation of the 'draw' function is incorrect. The 'count' function", "tokens": 5756, "instructions": "instructions.md\n# Instructions\n\nAdd the mine counts to a completed Minesweeper board.\n\nMinesweeper is a popular game where the user has to find the mines using\nnumeric hints that indicate how many mines are directly adjacent\n(horizontally, vertically, diagonally) to a square.\n\nIn this exercise you have to create some code that counts the number of\nmines adjacent to a given empty square and replaces that square with the\ncount.\n\nThe board is a rectangle composed of blank space (' ') characters. A mine\nis represented by an asterisk ('\\*') character.\n\nIf a given space has no adjacent mines at all, leave that square blank.\n\n## Examples\n\nFor example you may receive a 5 x 4 board like this (empty spaces are\nrepresented here with the '\u00b7' character for display on screen):\n\n```\n\u00b7*\u00b7*\u00b7\n\u00b7\u00b7*\u00b7\u00b7\n\u00b7\u00b7*\u00b7\u00b7\n\u00b7\u00b7\u00b7\u00b7\u00b7\n```\n\nAnd your code will transform it into this:\n\n```\n1*3*1\n13*31\n\u00b72*2\u00b7\n\u00b7111\u00b7\n```\n\n", "code": "minesweeper.clj\n(ns minesweeper)\n\n(defn count_mines [board row col]\n  (let [rows (count board)\n        cols (count (first board))\n        neighbors [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n    (count (filter #(= \\* (get-in board [(+ row (first %)) (+ col (second %))] \\space))\n                   (filter #(and (<= 0 (+ row (first %))) (< (+ row (first %)) rows)\n                                 (<= 0 (+ col (second %))) (< (+ col (second %)) cols))\n                           neighbors)))))\n(defn draw [board]\n  (let [rows (count board)\n        cols (count (first board))]\n    (map (fn [row]\n           (apply str\n                  (map (fn [col]\n                         (let [cell (get-in board [row col])]\n                           (if (= cell \\*)\n                             \\*\n                             (let [mines (count_mines board row col)]\n                               (if (zero? mines)\n                                 \\space\n                                 (str mines))))))\n                       (range cols))))\n         (range rows))))\n", "test-output": "test_output.txt\n\nlein test minesweeper-test\n\nlein test :only minesweeper-test/cross\n\nERROR in (cross) (RT.java:667)\nexpected: (= (draw (join line-separator [\"  *  \" \"  *  \" \"*****\" \"  *  \" \"  *  \"])) (join line-separator [\" 2*2 \" \"25*52\" \"*****\" \"25*52\" \" 2*2 \"]))\n  actual: java.lang.UnsupportedOperationException: count not supported on this type: Character\n at clojure.lang.RT.countFrom (RT.java:667)\n    clojure.lang.RT.count (RT.java:639)\n    minesweeper$draw.invokeStatic (minesweeper.clj:13)\n    minesweeper$draw.invoke (minesweeper.clj:11)\n    minesweeper_test$fn__485.invokeStatic (minesweeper_test.clj:52)\n    minesweeper_test/fn (minesweeper_test.clj:51)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357.invoke (form-init8033012716838714793.clj:1)\n    user$eval224.invokeStatic (form-init8033012716838714793.clj:1)\n    user$eval224.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only minesweeper-test/zero-size-board\n\nFAIL in (zero-size-board) (minesweeper_test.clj:9)\nexpected: (= (draw \"\") \"\")\n  actual: (not (= () \"\"))\n\nlein test :only minesweeper-test/horizontal-line\n\nERROR in (horizontal-line) (RT.java:667)\nexpected: (= (draw \" * * \") \"1*2*1\")\n  actual: java.lang.UnsupportedOperationException: count not supported on this type: Character\n at clojure.lang.RT.countFrom (RT.java:667)\n    clojure.lang.RT.count (RT.java:639)\n    minesweeper$draw.invokeStatic (minesweeper.clj:13)\n    minesweeper$draw.invoke (minesweeper.clj:11)\n    minesweeper_test$fn__475.invokeStatic (minesweeper_test.clj:36)\n    minesweeper_test/fn (minesweeper_test.clj:35)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357.invoke (form-init8033012716838714793.clj:1)\n    user$eval224.invokeStatic (form-init8033012716838714793.clj:1)\n    user$eval224.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only minesweeper-test/surrounded\n\nERROR in (surrounded) (RT.java:667)\nexpected: (= (draw (join line-separator [\"***\" \"* *\" \"***\"])) (join line-separator [\"***\" \"*8*\" \"***\"]))\n  actual: java.lang.UnsupportedOperationException: count not supported on this type: Character\n at clojure.lang.RT.countFrom (RT.java:667)\n    clojure.lang.RT.count (RT.java:639)\n    minesweeper$draw.invokeStatic (minesweeper.clj:13)\n    minesweeper$draw.invoke (minesweeper.clj:11)\n    minesweeper_test$fn__465.invokeStatic (minesweeper_test.clj:20)\n    minesweeper_test/fn (minesweeper_test.clj:19)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357.invoke (form-init8033012716838714793.clj:1)\n    user$eval224.invokeStatic (form-init8033012716838714793.clj:1)\n    user$eval224.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only minesweeper-test/board-full-of-mines\n\nERROR in (board-full-of-mines) (RT.java:667)\nexpected: (= (draw (join line-separator [\"***\" \"***\" \"***\"])) (join line-separator [\"***\" \"***\" \"***\"]))\n  actual: java.lang.UnsupportedOperationException: count not supported on this type: Character\n at clojure.lang.RT.countFrom (RT.java:667)\n    clojure.lang.RT.count (RT.java:639)\n    minesweeper$draw.invokeStatic (minesweeper.clj:13)\n    minesweeper$draw.invoke (minesweeper.clj:11)\n    minesweeper_test$fn__470.invokeStatic (minesweeper_test.clj:28)\n    minesweeper_test/fn (minesweeper_test.clj:27)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357.invoke (form-init8033012716838714793.clj:1)\n    user$eval224.invokeStatic (form-init8033012716838714793.clj:1)\n    user$eval224.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only minesweeper-test/empty-board\n\nERROR in (empty-board) (RT.java:667)\nexpected: (= (draw (join line-separator [\"   \" \"   \" \"   \"])) (join line-separator [\"   \" \"   \" \"   \"]))\n  actual: java.lang.UnsupportedOperationException: count not supported on this type: Character\n at clojure.lang.RT.countFrom (RT.java:667)\n    clojure.lang.RT.count (RT.java:639)\n    minesweeper$draw.invokeStatic (minesweeper.clj:13)\n    minesweeper$draw.invoke (minesweeper.clj:11)\n    minesweeper_test$fn__460.invokeStatic (minesweeper_test.clj:12)\n    minesweeper_test/fn (minesweeper_test.clj:11)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357.invoke (form-init8033012716838714793.clj:1)\n    user$eval224.invokeStatic (form-init8033012716838714793.clj:1)\n    user$eval224.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only minesweeper-test/vertical-line\n\nERROR in (vertical-line) (RT.java:667)\nexpected: (= (draw (join line-separator [\" \" \"*\" \" \" \"*\" \" \"])) (join line-separator [\"1\" \"*\" \"2\" \"*\" \"1\"]))\n  actual: java.lang.UnsupportedOperationException: count not supported on this type: Character\n at clojure.lang.RT.countFrom (RT.java:667)\n    clojure.lang.RT.count (RT.java:639)\n    minesweeper$draw.invokeStatic (minesweeper.clj:13)\n    minesweeper$draw.invoke (minesweeper.clj:11)\n    minesweeper_test$fn__480.invokeStatic (minesweeper_test.clj:40)\n    minesweeper_test/fn (minesweeper_test.clj:39)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init8033012716838714793.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init8033012716838714793.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init8033012716838714793.clj:1)\n    user$eval224$fn__357.invoke (form-init8033012716838714793.clj:1)\n    user$eval224.invokeStatic (form-init8033012716838714793.clj:1)\n    user$eval224.invoke (form-init8033012716838714793.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 7 tests containing 7 assertions.\n1 failures, 6 errors.\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "nth-prime", "tokens": 4005, "instructions": "instructions.md\n# Instructions\n\nGiven a number n, determine what the nth prime is.\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that\nthe 6th prime is 13.\n\nIf your language provides methods in the standard library to deal with prime\nnumbers, pretend they don't exist and implement them yourself.\n\n", "code": "nth_prime.clj\n(ns nth-prime)\n(defn is-prime?\n  \"Check if a number is prime.\"\n  [n]\n  (cond\n    (< n 2) false\n    (= n 2) true\n    :else (not (some #(zero? (mod n %)) (range 2 (inc (Math/sqrt n)))))))\n\n(defn nth-prime \n  \"Returns the prime number in the nth position.\"\n  [n] ;; <- arglist goes here\n  (when (zero? n)\n    (throw (IllegalArgumentException. \"There is no zeroth prime\")))\n  (loop [i 2 count 0]\n    (if (= count n)\n      (dec i)\n      (recur (inc i) (if (is-prime? i) (inc count) count))))\n  )\n", "test-output": "test_output.txt\n\nlein test nth-prime-test\n\nRan 5 tests containing 5 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "nucleotide-count", "response": "The coder failed the test because there is a duplicated line in the code and an unmatched delimiter. The duplicate line causes confusion, and the unmatched delimiter leads to a syntax error.\n\nreason: duplication\n", "reason": "duplication", "tokens": 5033, "instructions": "instructions.md\n# Instructions\n\nEach of us inherits from our biological parents a set of chemical instructions known as DNA that influence how our bodies are constructed. All known life depends on DNA!\n\n> Note: You do not need to understand anything about nucleotides or DNA to complete this exercise.\n\nDNA is a long chain of other chemicals and the most important are the four nucleotides, adenine, cytosine, guanine and thymine. A single DNA chain can contain billions of these four nucleotides and the order in which they occur is important!\nWe call the order of these nucleotides in a bit of DNA a \"DNA sequence\".\n\nWe represent a DNA sequence as an ordered collection of these four nucleotides and a common way to do that is with a string of characters such as \"ATTACG\" for a DNA sequence of 6 nucleotides.\n'A' for adenine, 'C' for cytosine, 'G' for guanine, and 'T' for thymine.\n\nGiven a string representing a DNA sequence, count how many of each nucleotide is present.\nIf the string contains characters that aren't A, C, G, or T then it is invalid and you should signal an error.\n\nFor example:\n\n```\n\"GATTACA\" -> 'A': 3, 'C': 1, 'G': 1, 'T': 2\n\"INVALID\" -> error\n```\n\n", "code": "nucleotide_count.clj\n(ns nucleotide-count)\n\n(defn count-of-nucleotide-in-strand [nucleotide strand]\n  (count (filter #(= nucleotide %) strand)))\n\n(defn nucleotide-counts [strand]\n(defn nucleotide-counts [strand]\n  (if (re-matches #\"^[ACGT]*$\" strand)\n    (let [nucleotides [\\A \\C \\G \\T]]\n      (into {} (map (fn [nucleotide] [nucleotide (count-of-nucleotide-in-strand nucleotide strand)]) nucleotides)))\n    (throw (IllegalArgumentException. \"Invalid DNA sequence\"))))\n    (throw (IllegalArgumentException. \"Invalid DNA sequence\"))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (nucleotide_count.clj:12:65).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat nucleotide_count_test$eval422$loading__6706__auto____423.invoke(nucleotide_count_test.clj:1)\n\tat nucleotide_count_test$eval422.invokeStatic(nucleotide_count_test.clj:1)\n\tat nucleotide_count_test$eval422.invoke(nucleotide_count_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init13879171650640313054.clj:1)\n\tat user$eval224.invoke(form-init13879171650640313054.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unmatched delimiter: )\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1373)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "octal", "tokens": 4321, "instructions": "instructions.md\n# Instructions\n\nConvert an octal number, represented as a string (e.g. '1735263'), to its\ndecimal equivalent using first principles (i.e. no, you may not use built-in or\nexternal libraries to accomplish the conversion).\n\nImplement octal to decimal conversion.  Given an octal input\nstring, your program should produce a decimal output.\n\n## Note\n\n- Implement the conversion yourself.\n  Do not use something else to perform the conversion for you.\n- Treat invalid input as octal 0.\n\n## About Octal (Base-8)\n\nDecimal is a base-10 system.\n\nA number 233 in base 10 notation can be understood\nas a linear combination of powers of 10:\n\n- The rightmost digit gets multiplied by 10^0 = 1\n- The next number gets multiplied by 10^1 = 10\n- ...\n- The *n*th number gets multiplied by 10^*(n-1)*.\n- All these values are summed.\n\nSo:\n\n```text\n   233 # decimal\n = 2*10^2 + 3*10^1 + 3*10^0\n = 2*100  + 3*10   + 3*1\n```\n\nOctal is similar, but uses powers of 8 rather than powers of 10.\n\nSo:\n\n```text\n   233 # octal\n = 2*8^2 + 3*8^1 + 3*8^0\n = 2*64  + 3*8   + 3*1\n = 128   + 24    + 3\n = 155\n```\n\n", "code": "octal.clj\n(ns octal)\n\n(defn to-decimal [octal-str]\n  (if (re-matches #\"^[0-7]*$\" octal-str)\n    (reduce (fn [acc digit]\n              (+ (* acc 8) (Character/digit (int digit) 8)))\n            0\n            octal-str)\n    0))\n", "test-output": "test_output.txt\n\nlein test octal-test\n\nRan 15 tests containing 15 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "pangram", "response": "The coder made a mistake by having an extra line of code outside the `let` block, causing a syntax error and the code to not compile.\n\nreason: syntax\n", "reason": "syntax", "tokens": 4808, "instructions": "instructions.md\n# Instructions\n\nYour task is to figure out if a sentence is a pangram.\n\nA pangram is a sentence using every letter of the alphabet at least once.\nIt is case insensitive, so it doesn't matter if a letter is lower-case (e.g. `k`) or upper-case (e.g. `K`).\n\nFor this exercise we only use the basic letters used in the English alphabet: `a` to `z`.\n\nintroduction.md\n# Introduction\n\nYou work for a company that sells fonts through their website.\nThey'd like to show a different sentence each time someone views a font on their website.\nTo give a comprehensive sense of the font, the random sentences should use **all** the letters in the English alphabet.\n\nThey're running a competition to get suggestions for sentences that they can use.\nYou're in charge of checking the submissions to see if they are valid.\n\n~~~~exercism/note\nPangram comes from Greek, \u03c0\u03b1\u03bd \u03b3\u03c1\u03ac\u03bc\u03bc\u03b1, pan gramma, which means \"every letter\".\n\nThe best known English pangram is:\n\n> The quick brown fox jumps over the lazy dog.\n~~~~\n\n", "code": "pangram.clj\n(ns pangram)\n\n(defn pangram? [sentence]\n  (let [letters (map char (range (int \\a) (inc (int \\z))))\n        lower-sentence (clojure.string/lower-case sentence)]\n    (every? #(not= (clojure.string/index-of lower-sentence %) -1) letters)))\n    (every? #(clojure.string/includes? lower-sentence %) letters)))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (pangram.clj:7:14).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3888)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3888)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.eval(Compiler.java:7173)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat pangram_test$eval422$loading__6706__auto____423.invoke(pangram_test.clj:1)\n\tat pangram_test$eval422.invokeStatic(pangram_test.clj:1)\n\tat pangram_test$eval422.invoke(pangram_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init6535514313268564156.clj:1)\n\tat user$eval224.invoke(form-init6535514313268564156.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unable to resolve symbol: lower-sentence in this context\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7413)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 91 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "pascals-triangle", "response": "The coder failed the test due to multiple issues. There are arithmetic exceptions, incorrect row values, and issues with creating a sequence from the triangle function. The primary reason for these failures is incorrect logic in the code.\n\nreason: logic\n", "reason": "logic", "tokens": 4655, "instructions": "instructions.md\n# Instructions\n\nCompute Pascal's triangle up to a given number of rows.\n\nIn Pascal's Triangle each number is computed by adding the numbers to\nthe right and left of the current position in the previous row.\n\n```text\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n# ... etc\n```\n\n", "code": "pascals_triangle.clj\n(ns pascals-triangle)\n\n(defn triangle [n]\n  (->> (iterate (fn [row]\n                  (conj (mapv + (cons 0 row) (conj row 0)) 1))\n                [1])\n       (take n)))\n\n(defn row [n]\n  (nth (triangle (inc n)) (dec n)))\n", "test-output": "test_output.txt\n\nlein test pascals-triangle-test\n\nlein test :only pascals-triangle-test/triangle-300th-row\n\nERROR in (triangle-300th-row) (Numbers.java:1576)\n300th row\nexpected: (some? (some #{768408467483699505953134992026497450726137182648496343119395977464120N} (row 300)))\n  actual: java.lang.ArithmeticException: integer overflow\n at clojure.lang.Numbers.throwIntOverflow (Numbers.java:1576)\n    clojure.lang.Numbers.add (Numbers.java:1893)\n    clojure.lang.Numbers$LongOps.add (Numbers.java:485)\n    clojure.lang.Numbers.add (Numbers.java:153)\n    clojure.core$_PLUS_.invokeStatic (core.clj:992)\n    clojure.core$_PLUS_.invoke (core.clj:984)\n    clojure.core$map$fn__5855.invoke (core.clj:2760)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.next (RT.java:709)\n    clojure.core$next__5371.invokeStatic (core.clj:64)\n    clojure.core.protocols$fn__8144.invokeStatic (protocols.clj:169)\n    clojure.core.protocols/fn (protocols.clj:124)\n    clojure.core.protocols$fn__8099$G__8094__8108.invoke (protocols.clj:19)\n    clojure.core.protocols$seq_reduce.invokeStatic (protocols.clj:31)\n    clojure.core.protocols$fn__8131.invokeStatic (protocols.clj:75)\n    clojure.core.protocols/fn (protocols.clj:75)\n    clojure.core.protocols$fn__8073$G__8068__8086.invoke (protocols.clj:13)\n    clojure.core$reduce.invokeStatic (core.clj:6828)\n    clojure.core$into.invokeStatic (core.clj:6895)\n    clojure.core$mapv.invokeStatic (core.clj:6903)\n    clojure.core$mapv.invoke (core.clj:6903)\n    pascals_triangle$triangle$fn__436.invoke (pascals_triangle.clj:5)\n    clojure.lang.Iterate.first (Iterate.java:47)\n    clojure.lang.RT.first (RT.java:688)\n    clojure.core$first__5369.invokeStatic (core.clj:55)\n    clojure.core$take$fn__5894.invoke (core.clj:2885)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.nthFrom (RT.java:920)\n    clojure.lang.RT.nth (RT.java:893)\n    pascals_triangle$row.invokeStatic (pascals_triangle.clj:10)\n    pascals_triangle$row.invoke (pascals_triangle.clj:9)\n    pascals_triangle_test$fn__479.invokeStatic (pascals_triangle_test.clj:39)\n    pascals_triangle_test/fn (pascals_triangle_test.clj:35)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init685344492930132861.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init685344492930132861.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357.invoke (form-init685344492930132861.clj:1)\n    user$eval224.invokeStatic (form-init685344492930132861.clj:1)\n    user$eval224.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pascals-triangle-test/test-third-row\n\nFAIL in (test-third-row) (pascals_triangle_test.clj:19)\nThird row\nexpected: (= (row 3) [1 2 1])\n  actual: (not (= [1 2 2 1 1] [1 2 1]))\n\nlein test :only pascals-triangle-test/test-fifth-row\n\nFAIL in (test-fifth-row) (pascals_triangle_test.clj:27)\nFifth row\nexpected: (= (row 5) [1 4 6 4 1])\n  actual: (not (= [1 4 7 7 5 3 2 1 1] [1 4 6 4 1]))\n\nlein test :only pascals-triangle-test/test-three-rows\n\nERROR in (test-three-rows) (RT.java:553)\nFirst 3 rows\nexpected: (= (take 3 triangle) [[1] [1 1] [1 2 1]])\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: pascals_triangle$triangle\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$take$fn__5894.invoke (core.clj:2884)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.LazySeq.equiv (LazySeq.java:102)\n    clojure.lang.Util.pcequiv (Util.java:124)\n    clojure.lang.Util.equiv (Util.java:32)\n    clojure.core$_EQ_.invokeStatic (core.clj:793)\n    clojure.core$_EQ_.invoke (core.clj:783)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.RestFn.applyTo (RestFn.java:132)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    pascals_triangle_test$fn__454.invokeStatic (pascals_triangle_test.clj:15)\n    pascals_triangle_test/fn (pascals_triangle_test.clj:13)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init685344492930132861.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init685344492930132861.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357.invoke (form-init685344492930132861.clj:1)\n    user$eval224.invokeStatic (form-init685344492930132861.clj:1)\n    user$eval224.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pascals-triangle-test/test-one-row\n\nERROR in (test-one-row) (RT.java:553)\nFirst row\nexpected: (= (take 1 triangle) [[1]])\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: pascals_triangle$triangle\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$take$fn__5894.invoke (core.clj:2884)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.LazySeq.equiv (LazySeq.java:102)\n    clojure.lang.Util.pcequiv (Util.java:124)\n    clojure.lang.Util.equiv (Util.java:32)\n    clojure.core$_EQ_.invokeStatic (core.clj:793)\n    clojure.core$_EQ_.invoke (core.clj:783)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.RestFn.applyTo (RestFn.java:132)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    pascals_triangle_test$fn__444.invokeStatic (pascals_triangle_test.clj:7)\n    pascals_triangle_test/fn (pascals_triangle_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init685344492930132861.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init685344492930132861.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357.invoke (form-init685344492930132861.clj:1)\n    user$eval224.invokeStatic (form-init685344492930132861.clj:1)\n    user$eval224.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pascals-triangle-test/triangle-20th-row\n\nFAIL in (triangle-20th-row) (pascals_triangle_test.clj:31)\n20th row\nexpected: (= (row 20) (let [v [1 19 171 969 3876 11628 27132 50388 75582 92378]] (into v (rseq v))))\n  actual: (not (= [1 19 172 987 4030 12461 30329 59652 96647 130965 150438 148487 127921 98086 68595 44995 28445 17690 10945 6765 4181 2584 1597 987 610 377 233 144 89 55 34 21 13 8 5 3 2 1 1] [1 19 171 969 3876 11628 27132 50388 75582 92378 92378 75582 50388 27132 11628 3876 969 171 19 1]))\n\nlein test :only pascals-triangle-test/test-fourth-row\n\nFAIL in (test-fourth-row) (pascals_triangle_test.clj:23)\nFourth row\nexpected: (= (row 4) [1 3 3 1])\n  actual: (not (= [1 3 4 3 2 1 1] [1 3 3 1]))\n\nlein test :only pascals-triangle-test/test-two-rows\n\nERROR in (test-two-rows) (RT.java:553)\nFirst two rows\nexpected: (= (take 2 triangle) [[1] [1 1]])\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: pascals_triangle$triangle\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core$take$fn__5894.invoke (core.clj:2884)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.LazySeq.equiv (LazySeq.java:102)\n    clojure.lang.Util.pcequiv (Util.java:124)\n    clojure.lang.Util.equiv (Util.java:32)\n    clojure.core$_EQ_.invokeStatic (core.clj:793)\n    clojure.core$_EQ_.invoke (core.clj:783)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.RestFn.applyTo (RestFn.java:132)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    pascals_triangle_test$fn__449.invokeStatic (pascals_triangle_test.clj:11)\n    pascals_triangle_test/fn (pascals_triangle_test.clj:9)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init685344492930132861.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init685344492930132861.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init685344492930132861.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init685344492930132861.clj:1)\n    user$eval224$fn__357.invoke (form-init685344492930132861.clj:1)\n    user$eval224.invokeStatic (form-init685344492930132861.clj:1)\n    user$eval224.invoke (form-init685344492930132861.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 8 tests containing 8 assertions.\n4 failures, 4 errors.\nTests failed.\n"},{"iterations": 2, "passed": true, "test": "perfect-numbers", "tokens": 4789, "instructions": "instructions.md\n# Instructions\n\nDetermine if a number is perfect, abundant, or deficient based on\nNicomachus' (60 - 120 CE) classification scheme for positive integers.\n\nThe Greek mathematician [Nicomachus](https://en.wikipedia.org/wiki/Nicomachus) devised a classification scheme for positive integers, identifying each as belonging uniquely to the categories of **perfect**, **abundant**, or **deficient** based on their [aliquot sum](https://en.wikipedia.org/wiki/Aliquot_sum). The aliquot sum is defined as the sum of the factors of a number not including the number itself. For example, the aliquot sum of 15 is (1 + 3 + 5) = 9\n\n- **Perfect**: aliquot sum = number\n  - 6 is a perfect number because (1 + 2 + 3) = 6\n  - 28 is a perfect number because (1 + 2 + 4 + 7 + 14) = 28\n- **Abundant**: aliquot sum > number\n  - 12 is an abundant number because (1 + 2 + 3 + 4 + 6) = 16\n  - 24 is an abundant number because (1 + 2 + 3 + 4 + 6 + 8 + 12) = 36\n- **Deficient**: aliquot sum < number\n  - 8 is a deficient number because (1 + 2 + 4) = 7\n  - Prime numbers are deficient\n\nImplement a way to determine whether a given number is **perfect**. Depending on your language track, you may also need to implement a way to determine whether a given number is **abundant** or **deficient**.\n\n", "code": "perfect_numbers.clj\n(ns perfect-numbers)\n\n(defn factors [num]\n  (filter #(zero? (mod num %)) (range 1 (inc (/ num 2)))))\n(defn aliquot-sum [num]\n  (reduce + (factors num)))\n(defn classify [num]\n  (let [aliquot (aliquot-sum num)]\n    (when (neg? num) (throw (IllegalArgumentException. \"Number must be positive\")))\n    (cond\n      (= aliquot num) :perfect\n      (> aliquot num) :abundant\n      :else :deficient)))\n", "test-output": "test_output.txt\n\nlein test perfect-numbers-test\n\nRan 4 tests containing 4 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "phone-number", "response": "The coder failed the test due to a syntax error in the code. The defn for the 'number' function is not properly formatted, causing the code to not be compiled/interpreted.\n\nreason: syntax\n", "reason": "syntax", "tokens": 5058, "instructions": "instructions.md\n# Instructions\n\nClean up user-entered phone numbers so that they can be sent SMS messages.\n\nThe **North American Numbering Plan (NANP)** is a telephone numbering system used by many countries in North America like the United States, Canada or Bermuda.\nAll NANP-countries share the same international country code: `1`.\n\nNANP numbers are ten-digit numbers consisting of a three-digit Numbering Plan Area code, commonly known as *area code*, followed by a seven-digit local number.\nThe first three digits of the local number represent the *exchange code*, followed by the unique four-digit number which is the *subscriber number*.\n\nThe format is usually represented as\n\n```text\n(NXX)-NXX-XXXX\n```\n\nwhere `N` is any digit from 2 through 9 and `X` is any digit from 0 through 9.\n\nYour task is to clean up differently formatted telephone numbers by removing punctuation and the country code (1) if present.\n\nFor example, the inputs\n\n- `+1 (613)-995-0253`\n- `613-995-0253`\n- `1 613 995 0253`\n- `613.995.0253`\n\nshould all produce the output\n\n`6139950253`\n\n**Note:** As this exercise only deals with telephone numbers used in NANP-countries, only 1 is considered a valid country code.\n\n", "code": "phone_number.clj\n(ns phone-number)\n\n(defn number\n(defn- valid-code? [code]\n  (let [first-digit (first code)]\n    (and (>= first-digit \\2) (<= first-digit \\9))))\n  [phone]\n  (let [digits (clojure.string/join (re-seq #\"\\d\" phone))]\n    (if (and (<= 10 (count digits) 11)\n             (or (= (count digits) 10) (= (first digits) \"1\"))\n             (valid-code? (subs digits (if (= (count digits) 11) 2 1) 4))\n             (valid-code? (subs digits (if (= (count digits) 11) 5 4) 7)))\n      (if (= (count digits) 11)\n        (subs digits 1)\n        digits)\n      \"0000000000\"))\n  )\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error macroexpanding clojure.core/defn at (phone_number.clj:3:1).\nCall to clojure.core/defn did not conform to spec.\n\tat clojure.lang.Compiler.checkSpecs(Compiler.java:6971)\n\tat clojure.lang.Compiler.macroexpand1(Compiler.java:6987)\n\tat clojure.lang.Compiler.macroexpand(Compiler.java:7074)\n\tat clojure.lang.Compiler.eval(Compiler.java:7160)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat phone_number_test$eval422$loading__6706__auto____423.invoke(phone_number_test.clj:1)\n\tat phone_number_test$eval422.invokeStatic(phone_number_test.clj:1)\n\tat phone_number_test$eval422.invoke(phone_number_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init16046712951208458796.clj:1)\n\tat user$eval224.invoke(form-init16046712951208458796.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: clojure.lang.ExceptionInfo: Call to clojure.core/defn did not conform to spec. {:clojure.spec.alpha/problems ({:path [:fn-tail :arity-1 :params], :pred clojure.core/vector?, :val (defn- valid-code? [code] (let [first-digit (first code)] (and (>= first-digit \\2) (<= first-digit \\9)))), :via [:clojure.core.specs.alpha/defn-args :clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/param-list :clojure.core.specs.alpha/param-list], :in [1]} {:path [:fn-tail :arity-n :bodies :params], :pred clojure.core/vector?, :val defn-, :via [:clojure.core.specs.alpha/defn-args :clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/params+body :clojure.core.specs.alpha/param-list :clojure.core.specs.alpha/param-list], :in [1 0]}), :clojure.spec.alpha/spec #object[clojure.spec.alpha$regex_spec_impl$reify__2509 0x2a037324 \"clojure.spec.alpha$regex_spec_impl$reify__2509@2a037324\"], :clojure.spec.alpha/value (number (defn- valid-code? [code] (let [first-digit (first code)] (and (>= first-digit \\2) (<= first-digit \\9)))) [phone] (let [digits (clojure.string/join (re-seq #\"\\d\" phone))] (if (and (<= 10 (count digits) 11) (or (= (count digits) 10) (= (first digits) \"1\")) (valid-code? (subs digits (if (= (count digits) 11) 2 1) 4)) (valid-code? (subs digits (if (= (count digits) 11) 5 4) 7))) (if (= (count digits) 11) (subs digits 1) digits) \"0000000000\"))), :clojure.spec.alpha/args (number (defn- valid-code? [code] (let [first-digit (first code)] (and (>= first-digit \\2) (<= first-digit \\9)))) [phone] (let [digits (clojure.string/join (re-seq #\"\\d\" phone))] (if (and (<= 10 (count digits) 11) (or (= (count digits) 10) (= (first digits) \"1\")) (valid-code? (subs digits (if (= (count digits) 11) 2 1) 4)) (valid-code? (subs digits (if (= (count digits) 11) 5 4) 7))) (if (= (count digits) 11) (subs digits 1) digits) \"0000000000\")))}\n\tat clojure.spec.alpha$macroexpand_check.invokeStatic(alpha.clj:705)\n\tat clojure.spec.alpha$macroexpand_check.invoke(alpha.clj:697)\n\tat clojure.lang.AFn.applyToHelper(AFn.java:156)\n\tat clojure.lang.AFn.applyTo(AFn.java:144)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.lang.Compiler.checkSpecs(Compiler.java:6969)\n\t... 73 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "pig-latin", "response": "The coder implemented the translation rules correctly, but the test suite timed out. It seems that the test suite might not have been able to call the implemented function properly or there might be an issue with the test suite itself.\n\nreason: other\n", "reason": "other", "tokens": 5707, "instructions": "instructions.md\n# Instructions\n\nImplement a program that translates from English to Pig Latin.\n\nPig Latin is a made-up children's language that's intended to be\nconfusing. It obeys a few simple rules (below), but when it's spoken\nquickly it's really difficult for non-children (and non-native speakers)\nto understand.\n\n- **Rule 1**: If a word begins with a vowel sound, add an \"ay\" sound to the end of the word. Please note that \"xr\" and \"yt\" at the beginning of a word make vowel sounds (e.g. \"xray\" -> \"xrayay\", \"yttria\" -> \"yttriaay\").\n- **Rule 2**: If a word begins with a consonant sound, move it to the end of the word and then add an \"ay\" sound to the end of the word. Consonant sounds can be made up of multiple consonants, a.k.a. a consonant cluster (e.g. \"chair\" -> \"airchay\").\n- **Rule 3**: If a word starts with a consonant sound followed by \"qu\", move it to the end of the word, and then add an \"ay\" sound to the end of the word (e.g. \"square\" -> \"aresquay\").\n- **Rule 4**: If a word contains a \"y\" after a consonant cluster or as the second letter in a two letter word it makes a vowel sound (e.g. \"rhythm\" -> \"ythmrhay\", \"my\" -> \"ymay\").\n\nThere are a few more rules for edge cases, and there are regional\nvariants too.\n\nSee <http://en.wikipedia.org/wiki/Pig_latin> for more details.\n\n", "code": "pig_latin.clj\n(ns pig-latin)\n(defn first-vowel-index [word]\n  (loop [i 0]\n    (let [c (nth word i)]\n      (cond\n        (>= i (count word)) i\n        (is-vowel? c) i\n        (and (= c \\q) (= (nth word (inc i)) \\u)) (+ i 2)\n        (and (> i 0) (= c \\y)) i\n        :else (recur (inc i))))))\n(defn is-vowel? [c]\n  (contains? #{\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U} c))\n\n(defn translate [word]\n  (let [index (first-vowel-index word)\n        prefix (subs word 0 index)\n        suffix (subs word index)]\n    (cond\n      (or (is-vowel? (first word)) (#{\\x \\y} (first word)) (#{\\X \\Y} (first word)))\n      (str word \"ay\")\n      :else\n      (str suffix prefix \"ay\"))))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "poker", "response": "The coder failed the test due to a syntax error in their code. The error message indicates that the symbol \"min-max\" cannot be resolved in the given context. This is likely because the coder has not imported or defined the \"min-max\" function, which is causing the code to fail compilation.\n\nreason: syntax\n", "reason": "syntax", "tokens": 6591, "instructions": "instructions.md\n# Instructions\n\nPick the best hand(s) from a list of poker hands.\n\nSee [wikipedia](https://en.wikipedia.org/wiki/List_of_poker_hands) for an\noverview of poker hands.\n\n", "code": "poker.clj\n(ns poker)\n\n\n(defn parse-card [card]\n  (let [[value suit] card]\n    [(get {:2 2 :3 3 :4 4 :5 5 :6 6 :7 7 :8 8 :9 9 :T 10 :J 11 :Q 12 :K 13 :A 14} value) suit]))\n\n(defn hand-rank [hand]\n  (let [cards (map parse-card hand)\n        values (map first cards)\n        suits (map second cards)\n        same-value-counts (frequencies values)\n        same-suit? (apply = suits)\n        consecutive? (let [min-max (apply min-max values)]\n                       (= (range (first min-max) (inc (second min-max))) values))]\n    (cond\n      (and same-suit? consecutive?) [0 (last values)] ;; Straight flush\n      (= 4 (apply max (vals same-value-counts))) [1 (key (find (fn [[k v]] (= v 4)) same-value-counts))] ;; Four of a kind\n      (and (= 3 (apply max (vals same-value-counts))) (= 2 (apply min (vals same-value-counts)))) [2 (key (find (fn [[k v]] (= v 3)) same-value-counts))] ;; Full house\n      same-suit? [3 (last (sort values))] ;; Flush\n      consecutive? [4 (last values)] ;; Straight\n      (= 3 (apply max (vals same-value-counts))) [5 (key (find (fn [[k v]] (= v 3)) same-value-counts))] ;; Three of a kind\n      (let [pairs (filter (fn [[k v]] (= v 2)) same-value-counts)]\n        (if (= 2 (count pairs)) [6 (apply max (map key pairs))] ;; Two pairs\n            (if (= 1 (count pairs)) [7 (key (first pairs))] ;; One pair\n                [8 (last (sort values))])))))) ;; High card\n\n(defn highest-card [hand1 hand2]\n  (let [hand1-values (map first (map parse-card hand1))\n        hand2-values (map first (map parse-card hand2))]\n    (if (> (apply max hand1-values) (apply max hand2-values)) hand1 hand2)))\n\n(defn best-hands [hands]\n  (let [ranked-hands (map (fn [hand] [hand (hand-rank hand)]) hands)\n        best-rank (apply min (map (fn [[_ rank]] (first rank)) ranked-hands))\n        best-hands (filter (fn [[_ rank]] (= best-rank (first rank))) ranked-hands)]\n    (if (= 1 (count best-hands))\n      (first (first best-hands))\n      (let [tie-break-rank (apply min (map (fn [[_ rank]] (second rank)) best-hands))\n            tie-break-hands (filter (fn [[_ rank]] (= tie-break-rank (second rank))) best-hands)]\n        (if (= 1 (count tie-break-hands))\n          (first (first tie-break-hands))\n          (map first (reduce (fn [acc [hand1 rank1] [hand2 rank2]]\n                               (if (= rank1 rank2) (conj acc hand1 hand2) (highest-card hand1 hand2)))\n                             []\n                             tie-break-hands)))))))", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (poker.clj:14:36).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3888)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6384)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$LetExpr$Parser.parse(Compiler.java:6384)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:596)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler.eval(Compiler.java:7180)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat poker_test$eval422$loading__6706__auto____423.invoke(poker_test.clj:1)\n\tat poker_test$eval422.invokeStatic(poker_test.clj:1)\n\tat poker_test$eval422.invoke(poker_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init13694815160649234339.clj:1)\n\tat user$eval224.invoke(form-init13694815160649234339.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unable to resolve symbol: min-max in this context\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7413)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 100 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "pov", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 5529, "instructions": "instructions.md\n# Instructions\n\nReparent a graph on a selected node.\n\nThis exercise is all about re-orientating a graph to see things from a different\npoint of view. For example family trees are usually presented from the\nancestor's perspective:\n\n```text\n    +------0------+\n    |      |      |\n  +-1-+  +-2-+  +-3-+\n  |   |  |   |  |   |\n  4   5  6   7  8   9\n```\n\nBut the same information can be presented from the perspective of any other node\nin the graph, by pulling it up to the root and dragging its relationships along\nwith it. So the same graph from 6's perspective would look like:\n\n```text\n        6\n        |\n  +-----2-----+\n  |           |\n  7     +-----0-----+\n        |           |\n      +-1-+       +-3-+\n      |   |       |   |\n      4   5       8   9\n```\n\nThis lets us more simply describe the paths between two nodes. So for example\nthe path from 6-9 (which in the first graph goes up to the root and then down to\na different leaf node) can be seen to follow the path 6-2-0-3-9\n\nThis exercise involves taking an input graph and re-orientating it from the point\nof view of one of the nodes.\n\n", "code": "pov.clj\n(ns pov)\n\n(defn of [graph node]\n  (let [new-graph (assoc graph node (get graph node #{}) )]\n    (reduce (fn [g k] (assoc g k (disj (get g k #{}) node))) new-graph (get graph node #{}) )))\n\n(defn path-from-to [graph from to]\n  (loop [path [from] visited #{from}]\n    (let [current (peek path)]\n      (cond\n        (= current to) path\n        (empty? (get graph current #{}) ) nil\n        :else (if-let [next (some #(when-not (visited %) %) (get graph current #{}) )]\n                (recur (conj path next) (conj visited next))\n                (recur (pop path) visited))))))\n", "test-output": "test_output.txt\n\nlein test pov-test\n\nlein test :only pov-test/path-from-target-to-parent\n\nFAIL in (path-from-target-to-parent) (pov_test.clj:133)\nexpected: (= [:x :parent] (pov/path-from-to :x :parent simple-tree))\n  actual: (not (= [:x :parent] nil))\n\nlein test :only pov-test/nested-trees\n\nERROR in (nested-trees) (RT.java:823)\nexpected: (= nested-pulled (pov/of :x deeply-nested))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__458.invokeStatic (pov_test.clj:109)\n    pov_test/fn (pov_test.clj:107)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/simple-trees\n\nERROR in (simple-trees) (RT.java:823)\nexpected: (= simple-pulled (pov/of :x simple-tree))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__453.invokeStatic (pov_test.clj:105)\n    pov_test/fn (pov_test.clj:103)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/path-from-target-to-sibling\n\nFAIL in (path-from-target-to-sibling) (pov_test.clj:137)\nexpected: (= [:x :parent :sib-c] (pov/path-from-to :x :sib-c large-flat))\n  actual: (not (= [:x :parent :sib-c] nil))\n\nlein test :only pov-test/not-found-input-nil\n\nERROR in (not-found-input-nil) (RT.java:823)\nexpected: (nil? (pov/of :x nil))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__488.invokeStatic (pov_test.clj:130)\n    pov_test/fn (pov_test.clj:129)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/path-from-x-to-2nd-cousin-1\n\nFAIL in (path-from-x-to-2nd-cousin-1) (pov_test.clj:141)\nexpected: (= [:x :parent :grand-parent :aunt :cousin-1 :2nd-cousin-1] (pov/path-from-to :x :2nd-cousin-1 target-with-children))\n  actual: (not (= [:x :parent :grand-parent :aunt :cousin-1 :2nd-cousin-1] nil))\n\nlein test :only pov-test/not-found-input-empty\n\nERROR in (not-found-input-empty) (RT.java:823)\nexpected: (nil? (pov/of :x []))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__483.invokeStatic (pov_test.clj:127)\n    pov_test/fn (pov_test.clj:126)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/moderate-trees\n\nERROR in (moderate-trees) (RT.java:823)\nexpected: (= cousins-pulled (pov/of :x cousins))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__468.invokeStatic (pov_test.clj:117)\n    pov_test/fn (pov_test.clj:115)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/extract-node-from-siblings\n\nERROR in (extract-node-from-siblings) (RT.java:823)\nexpected: (= flat-pulled (pov/of :x large-flat))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__463.invokeStatic (pov_test.clj:113)\n    pov_test/fn (pov_test.clj:111)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/not-found-cannot-reparent\n\nERROR in (not-found-cannot-reparent) (RT.java:823)\nexpected: (nil? (pov/of :not-found! target-with-children))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__478.invokeStatic (pov_test.clj:124)\n    pov_test/fn (pov_test.clj:123)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/singletons\n\nERROR in (singletons) (RT.java:823)\nexpected: (= singleton (pov/of :x singleton))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__448.invokeStatic (pov_test.clj:101)\n    pov_test/fn (pov_test.clj:99)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only pov-test/complex-trees\n\nERROR in (complex-trees) (RT.java:823)\nexpected: (= with-kids-pulled (pov/of :x target-with-children))\n  actual: java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class clojure.lang.Associative (clojure.lang.Keyword and clojure.lang.Associative are in unnamed module of loader 'app')\n at clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core/assoc (core.clj:190)\n    pov$of.invokeStatic (pov.clj:4)\n    pov$of.invoke (pov.clj:3)\n    pov_test$fn__473.invokeStatic (pov_test.clj:121)\n    pov_test/fn (pov_test.clj:119)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init14257834709225791412.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init14257834709225791412.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init14257834709225791412.clj:1)\n    user$eval224$fn__357.invoke (form-init14257834709225791412.clj:1)\n    user$eval224.invokeStatic (form-init14257834709225791412.clj:1)\n    user$eval224.invoke (form-init14257834709225791412.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 13 tests containing 13 assertions.\n3 failures, 9 errors.\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "prime-factors", "tokens": 1861, "instructions": "instructions.md\n# Instructions\n\nCompute the prime factors of a given natural number.\n\nA prime number is only evenly divisible by itself and 1.\n\nNote that 1 is not a prime number.\n\n## Example\n\nWhat are the prime factors of 60?\n\n- Our first divisor is 2. 2 goes into 60, leaving 30.\n- 2 goes into 30, leaving 15.\n  - 2 doesn't go cleanly into 15. So let's move on to our next divisor, 3.\n- 3 goes cleanly into 15, leaving 5.\n  - 3 does not go cleanly into 5. The next possible factor is 4.\n  - 4 does not go cleanly into 5. The next possible factor is 5.\n- 5 does go cleanly into 5.\n- We're left only with 1, so now, we're done.\n\nOur successful divisors in that computation represent the list of prime\nfactors of 60: 2, 2, 3, and 5.\n\nYou can check this yourself:\n\n- 2 * 2 * 3 * 5\n- = 4 * 15\n- = 60\n- Success!\n\n", "code": "prime_factors.clj\n(ns prime-factors)\n\n(defn of [n]\n  (loop [factors []\n         divisor 2\n         num n]\n    (cond\n      (< num 2) factors\n      (zero? (mod num divisor)) (recur (conj factors divisor) divisor (/ num divisor))\n      :else (recur factors (inc divisor) num))))\n", "test-output": "test_output.txt\n\nlein test prime-factors-test\n\nRan 11 tests containing 11 assertions.\n0 failures, 0 errors.\n"},{"iterations": 1, "passed": true, "test": "protein-translation", "tokens": 2359, "instructions": "instructions.md\n# Instructions\n\nTranslate RNA sequences into proteins.\n\nRNA can be broken into three nucleotide sequences called codons, and then translated to a polypeptide like so:\n\nRNA: `\"AUGUUUUCU\"` => translates to\n\nCodons: `\"AUG\", \"UUU\", \"UCU\"`\n=> which become a polypeptide with the following sequence =>\n\nProtein: `\"Methionine\", \"Phenylalanine\", \"Serine\"`\n\nThere are 64 codons which in turn correspond to 20 amino acids; however, all of the codon sequences and resulting amino acids are not important in this exercise.  If it works for one codon, the program should work for all of them.\nHowever, feel free to expand the list in the test suite to include them all.\n\nThere are also three terminating codons (also known as 'STOP' codons); if any of these codons are encountered (by the ribosome), all translation ends and the protein is terminated.\n\nAll subsequent codons after are ignored, like this:\n\nRNA: `\"AUGUUUUCUUAAAUG\"` =>\n\nCodons: `\"AUG\", \"UUU\", \"UCU\", \"UAA\", \"AUG\"` =>\n\nProtein: `\"Methionine\", \"Phenylalanine\", \"Serine\"`\n\nNote the stop codon `\"UAA\"` terminates the translation and the final methionine is not translated into the protein sequence.\n\nBelow are the codons and resulting Amino Acids needed for the exercise.\n\nCodon                 | Protein\n:---                  | :---\nAUG                   | Methionine\nUUU, UUC              | Phenylalanine\nUUA, UUG              | Leucine\nUCU, UCC, UCA, UCG    | Serine\nUAU, UAC              | Tyrosine\nUGU, UGC              | Cysteine\nUGG                   | Tryptophan\nUAA, UAG, UGA         | STOP\n\nLearn more about [protein translation on Wikipedia](http://en.wikipedia.org/wiki/Translation_(biology))\n\n", "code": "protein_translation.clj\n(ns protein-translation)\n\n(defn translate-codon [codon]\n  (case codon\n    \"AUG\" \"Methionine\"\n    \"UUU\" \"Phenylalanine\"\n    \"UUC\" \"Phenylalanine\"\n    \"UUA\" \"Leucine\"\n    \"UUG\" \"Leucine\"\n    \"UCU\" \"Serine\"\n    \"UCC\" \"Serine\"\n    \"UCA\" \"Serine\"\n    \"UCG\" \"Serine\"\n    \"UAU\" \"Tyrosine\"\n    \"UAC\" \"Tyrosine\"\n    \"UGU\" \"Cysteine\"\n    \"UGC\" \"Cysteine\"\n    \"UGG\" \"Tryptophan\"\n    \"UAA\" \"STOP\"\n    \"UAG\" \"STOP\"\n    \"UGA\" \"STOP\"))\n\n(defn translate-rna [rna]\n  (let [codons (re-seq #\"\\w{3}\" rna)\n        proteins (map translate-codon codons)]\n    (take-while #(not= % \"STOP\") proteins)))\n", "test-output": "test_output.txt\n\nlein test protein-translation-test\n\nRan 11 tests containing 20 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "proverb", "response": "The coder implemented the logic correctly, but there is an issue with the formatting of the output string. The test suite is expecting the output to have no extra newline characters, but the coder's implementation adds extra newline characters in the output.\n\nreason: wording\n", "reason": "wording", "tokens": 3976, "instructions": "instructions.md\n# Instructions\n\nFor want of a horseshoe nail, a kingdom was lost, or so the saying goes.\n\nGiven a list of inputs, generate the relevant proverb. For example, given the list `[\"nail\", \"shoe\", \"horse\", \"rider\", \"message\", \"battle\", \"kingdom\"]`, you will output the full text of this proverbial rhyme:\n\n```text\nFor want of a nail the shoe was lost.\nFor want of a shoe the horse was lost.\nFor want of a horse the rider was lost.\nFor want of a rider the message was lost.\nFor want of a message the battle was lost.\nFor want of a battle the kingdom was lost.\nAnd all for the want of a nail.\n```\n\nNote that the list of inputs may vary; your solution should be able to handle lists of arbitrary length and content. No line of the output text should be a static, unchanging string; all should vary according to the input given.\n\n", "code": "proverb.clj\n(ns proverb)\n\n(defn recite [inputs]\n  (if (empty? inputs)\n    \"\"\n    (let [proverb-lines (map #(str \"For want of a \" %1 \" the \" %2 \" was lost.\") inputs (rest inputs))]\n      (clojure.string/join \"\\n\" (concat proverb-lines [\"And all for the want of a \" (first inputs) \".\"])))))\n", "test-output": "test_output.txt\n\nlein test proverb-test\n\nlein test :only proverb-test/four-pieces-modernized\n\nFAIL in (four-pieces-modernized) (proverb_test.clj:40)\nexpected: (= (recite (quote (\"pin\" \"gun\" \"soldier\" \"battle\"))) (str/join \"\\n\" [\"For want of a pin the gun was lost.\" \"For want of a gun the soldier was lost.\" \"For want of a soldier the battle was lost.\" \"And all for the want of a pin.\"]))\n  actual: (not (= \"For want of a pin the gun was lost.\\nFor want of a gun the soldier was lost.\\nFor want of a soldier the battle was lost.\\nAnd all for the want of a \\npin\\n.\" \"For want of a pin the gun was lost.\\nFor want of a gun the soldier was lost.\\nFor want of a soldier the battle was lost.\\nAnd all for the want of a pin.\"))\n\nlein test :only proverb-test/one-piece\n\nFAIL in (one-piece) (proverb_test.clj:12)\nexpected: (= (recite (quote (\"nail\"))) \"And all for the want of a nail.\")\n  actual: (not (= \"And all for the want of a \\nnail\\n.\" \"And all for the want of a nail.\"))\n\nlein test :only proverb-test/three-pieces\n\nFAIL in (three-pieces) (proverb_test.clj:23)\nexpected: (= (recite (quote (\"nail\" \"shoe\" \"horse\"))) (str/join \"\\n\" [\"For want of a nail the shoe was lost.\" \"For want of a shoe the horse was lost.\" \"And all for the want of a nail.\"]))\n  actual: (not (= \"For want of a nail the shoe was lost.\\nFor want of a shoe the horse was lost.\\nAnd all for the want of a \\nnail\\n.\" \"For want of a nail the shoe was lost.\\nFor want of a shoe the horse was lost.\\nAnd all for the want of a nail.\"))\n\nlein test :only proverb-test/full-proverb\n\nFAIL in (full-proverb) (proverb_test.clj:30)\nexpected: (= (recite (quote (\"nail\" \"shoe\" \"horse\" \"rider\" \"message\" \"battle\" \"kingdom\"))) (str/join \"\\n\" [\"For want of a nail the shoe was lost.\" \"For want of a shoe the horse was lost.\" \"For want of a horse the rider was lost.\" \"For want of a rider the message was lost.\" \"For want of a message the battle was lost.\" \"For want of a battle the kingdom was lost.\" \"And all for the want of a nail.\"]))\n  actual: (not (= \"For want of a nail the shoe was lost.\\nFor want of a shoe the horse was lost.\\nFor want of a horse the rider was lost.\\nFor want of a rider the message was lost.\\nFor want of a message the battle was lost.\\nFor want of a battle the kingdom was lost.\\nAnd all for the want of a \\nnail\\n.\" \"For want of a nail the shoe was lost.\\nFor want of a shoe the horse was lost.\\nFor want of a horse the rider was lost.\\nFor want of a rider the message was lost.\\nFor want of a message the battle was lost.\\nFor want of a battle the kingdom was lost.\\nAnd all for the want of a nail.\"))\n\nlein test :only proverb-test/two-pieces\n\nFAIL in (two-pieces) (proverb_test.clj:17)\nexpected: (= (recite (quote (\"nail\" \"shoe\"))) (str/join \"\\n\" [\"For want of a nail the shoe was lost.\" \"And all for the want of a nail.\"]))\n  actual: (not (= \"For want of a nail the shoe was lost.\\nAnd all for the want of a \\nnail\\n.\" \"For want of a nail the shoe was lost.\\nAnd all for the want of a nail.\"))\n\nRan 6 tests containing 6 assertions.\n5 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "queen-attack", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 4367, "instructions": "instructions.md\n# Instructions\n\nGiven the position of two queens on a chess board, indicate whether or not they\nare positioned so that they can attack each other.\n\nIn the game of chess, a queen can attack pieces which are on the same\nrow, column, or diagonal.\n\nA chessboard can be represented by an 8 by 8 array.\n\nSo if you're told the white queen is at (2, 3) and the black queen at\n(5, 6), then you'd know you've got a set-up like so:\n\n```text\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ W _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ B _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n```\n\nYou'd also be able to answer whether the queens can attack each other.\nIn this case, that answer would be yes, they can, because both pieces\nshare a diagonal.\n\n", "code": "queen_attack.clj\n(ns queen-attack)\n\n(defn board-string [white-queen black-queen]\n  (let [board (vec (repeat 8 (vec (repeat 8 \".\"))))]\n    (-> board\n        (assoc-in white-queen \"W\")\n        (assoc-in black-queen \"B\")\n        (mapv #(clojure.string/join \" \" %))\n        (clojure.string/join \"\\n\")\n        (str \"\\n\"))))\n\n(defn can-attack [white-queen black-queen]\n  (let [[wx wy] white-queen\n        [bx by] black-queen]\n    (or (= wx bx)\n        (= wy by)\n        (= (Math/abs (- wx bx)) (Math/abs (- wy by))))))\n", "test-output": "test_output.txt\n\nlein test queen-attack-test\n\nlein test :only queen-attack-test/build-board\n\nERROR in (build-board) (AFn.java:429)\nexpected: (= board (queen-attack/board-string {:w [2 4], :b [6 6]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/board-string\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__458.invokeStatic (queen_attack_test.clj:28)\n    queen_attack_test/fn (queen_attack_test.clj:27)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/handles-empty-board\n\nERROR in (handles-empty-board) (AFn.java:429)\nexpected: (= empty-board (queen-attack/board-string {}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/board-string\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__453.invokeStatic (queen_attack_test.clj:26)\n    queen_attack_test/fn (queen_attack_test.clj:25)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= false (queen-attack/can-attack {:w [2 3], :b [4 7]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__464.invoke (queen_attack_test.clj:31)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:31)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [2 4], :b [2 7]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__468.invoke (queen_attack_test.clj:32)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:32)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [5 4], :b [2 4]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__472.invoke (queen_attack_test.clj:33)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:33)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [1 1], :b [6 6]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__476.invoke (queen_attack_test.clj:34)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:34)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [0 6], :b [1 7]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__480.invoke (queen_attack_test.clj:35)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:35)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [4 1], :b [6 3]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__484.invoke (queen_attack_test.clj:36)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:36)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [2 3], :b [5 0]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463$fn__488.invoke (queen_attack_test.clj:37)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:37)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only queen-attack-test/finds-attack-positions\n\nERROR in (finds-attack-positions) (AFn.java:429)\nexpected: (= true (queen-attack/can-attack {:w [2 3], :b [0 5]}))\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: queen-attack/can-attack\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    queen_attack_test$fn__463.invokeStatic (queen_attack_test.clj:38)\n    queen_attack_test/fn (queen_attack_test.clj:30)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init7363897856324405590.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init7363897856324405590.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init7363897856324405590.clj:1)\n    user$eval224$fn__357.invoke (form-init7363897856324405590.clj:1)\n    user$eval224.invokeStatic (form-init7363897856324405590.clj:1)\n    user$eval224.invoke (form-init7363897856324405590.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 3 tests containing 10 assertions.\n0 failures, 10 errors.\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "raindrops", "tokens": 1884, "instructions": "instructions.md\n# Instructions\n\nYour task is to convert a number into a string that contains raindrop sounds corresponding to certain potential factors. A factor is a number that evenly divides into another number, leaving no remainder. The simplest way to test if a one number is a factor of another is to use the [modulo operation](https://en.wikipedia.org/wiki/Modulo_operation).\n\nThe rules of `raindrops` are that if a given number:\n\n- has 3 as a factor, add 'Pling' to the result.\n- has 5 as a factor, add 'Plang' to the result.\n- has 7 as a factor, add 'Plong' to the result.\n- _does not_ have any of 3, 5, or 7 as a factor, the result should be the digits of the number.\n\n## Examples\n\n- 28 has 7 as a factor, but not 3 or 5, so the result would be \"Plong\".\n- 30 has both 3 and 5 as factors, but not 7, so the result would be \"PlingPlang\".\n- 34 is not factored by 3, 5, or 7, so the result would be \"34\".\n\n", "code": "raindrops.clj\n(ns raindrops)\n\n(defn convert [n]\n  (let [factors (concat (if (zero? (mod n 3)) [\"Pling\"] [])\n                        (if (zero? (mod n 5)) [\"Plang\"] [])\n                        (if (zero? (mod n 7)) [\"Plong\"] []))]\n    (if (empty? factors)\n      (str n)\n      (apply str factors))))\n", "test-output": "test_output.txt\n\nlein test raindrops-test\n\nRan 16 tests containing 16 assertions.\n0 failures, 0 errors.\n"},{"iterations": 1, "passed": true, "test": "reverse-string", "tokens": 1528, "instructions": "instructions.md\n# Instructions\n\nReverse a string\n\nFor example:\ninput: \"cool\"\noutput: \"looc\"\n\n", "code": "reverse_string.clj\n(ns reverse-string)\n\n(defn reverse-string [s]\n  (apply str (reverse s)))\n", "test-output": "test_output.txt\n\nlein test reverse-string-test\n\nRan 6 tests containing 6 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "rna-transcription", "response": "The coder failed because they did not define the `dna-to-rna` function and they left random lines with incorrect syntax in the code.\n\nreason: syntax\n", "reason": "syntax", "tokens": 5055, "instructions": "instructions.md\n# Instructions\n\nYour task is determine the RNA complement of a given DNA sequence.\n\nBoth DNA and RNA strands are a sequence of nucleotides.\n\nThe four nucleotides found in DNA are adenine (**A**), cytosine (**C**), guanine (**G**) and thymine (**T**).\n\nThe four nucleotides found in RNA are adenine (**A**), cytosine (**C**), guanine (**G**) and uracil (**U**).\n\nGiven a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement:\n\n- `G` -> `C`\n- `C` -> `G`\n- `T` -> `A`\n- `A` -> `U`\n\n~~~~exercism/note\nIf you want to look at how the inputs and outputs are structured, take a look at the examples in the test suite.\n~~~~\n\nintroduction.md\n# Introduction\n\nYou work for a bioengineering company that specializes in developing therapeutic solutions.\n\nYour team has just been given a new project to develop a targeted therapy for a rare type of cancer.\n\n~~~~exercism/note\nIt's all very complicated, but the basic idea is that sometimes people's bodies produce too much of a given protein.\nThat can cause all sorts of havoc.\n\nBut if you can create a very specific molecule (called a micro-RNA), it can prevent the protein from being produced.\n\nThis technique is called [RNA Interference][rnai].\n\n[rnai]: https://admin.acceleratingscience.com/ask-a-scientist/what-is-rnai/\n~~~~\n\n", "code": "rna_transcription.clj\n(ns rna-transcription)\n\n(defn to-rna [dna]\n  (apply str (map dna-to-rna dna)))\n    \\G \\C\n    \\C \\G\n    \\T \\A\n    \\A \\U))\n  (apply str (map dna-to-rna dna))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (rna_transcription.clj:4:14).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3888)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3888)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7094)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.access$300(Compiler.java:38)\n\tat clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:596)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7106)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler.eval(Compiler.java:7180)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat rna_transcription_test$eval422$loading__6706__auto____423.invoke(rna_transcription_test.clj:1)\n\tat rna_transcription_test$eval422.invokeStatic(rna_transcription_test.clj:1)\n\tat rna_transcription_test$eval422.invoke(rna_transcription_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init6607190722119255154.clj:1)\n\tat user$eval224.invoke(form-init6607190722119255154.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unable to resolve symbol: dna-to-rna in this context\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7413)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 92 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "robot-name", "response": "The coder implemented the robot name generation and reset functionality correctly. However, the test suite timed out, which indicates that the test took too long to execute. This could be due to inefficient code or an issue with the test suite itself.\n\nreason: other\n", "reason": "other", "tokens": 5144, "instructions": "instructions.md\n# Instructions\n\nManage robot factory settings.\n\nWhen a robot comes off the factory floor, it has no name.\n\nThe first time you turn on a robot, a random name is generated in the format\nof two uppercase letters followed by three digits, such as RX837 or BC811.\n\nEvery once in a while we need to reset a robot to its factory settings,\nwhich means that its name gets wiped. The next time you ask, that robot will\nrespond with a new random name.\n\nThe names must be random: they should not follow a predictable sequence.\nUsing random names means a risk of collisions. Your solution must ensure that\nevery existing robot has a unique name.\n\n", "code": "robot_name.clj\n(ns robot-name)\n(:require [clojure.string :as str])\n(:import (java.util.concurrent.atomic AtomicReference))\n\n(defn- generate-random-name []\n  (str (char (+ (rand-int 26) 65))\n       (char (+ (rand-int 26) 65))\n       (format \"%03d\" (rand-int 1000))))\n\n(defn robot []\n  (AtomicReference. {:name (generate-random-name)}))\n\n(defn robot-name [robot]\n  (:name @robot))\n\n(defn reset-name [robot]\n  (swap! robot update :name (fn [_] (generate-random-name))))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "robot-simulator", "response": "The coder failed the test due to a syntax error in their code. There is an unmatched delimiter \"]\" at line 17.\n\nreason: syntax\n", "reason": "syntax", "tokens": 5664, "instructions": "instructions.md\n# Instructions\n\nWrite a robot simulator.\n\nA robot factory's test facility needs a program to verify robot movements.\n\nThe robots have three possible movements:\n\n- turn right\n- turn left\n- advance\n\nRobots are placed on a hypothetical infinite grid, facing a particular direction (north, east, south, or west) at a set of {x,y} coordinates,\ne.g., {3,8}, with coordinates increasing to the north and east.\n\nThe robot then receives a number of instructions, at which point the testing facility verifies the robot's new position, and in which direction it is pointing.\n\n- The letter-string \"RAALAL\" means:\n  - Turn right\n  - Advance twice\n  - Turn left\n  - Advance once\n  - Turn left yet again\n- Say a robot starts at {7, 3} facing north.\n  Then running this stream of instructions should leave it at {9, 4} facing west.\n\n", "code": "robot_simulator.clj\n(ns robot-simulator)\n\n(defn robot\n  [x y direction]\n  {:position [x y] :direction direction})\n\n(defn simulate\n  [robot instructions]\n  (loop [robot robot\n         instrs (seq instructions)]\n    (if (empty? instrs)\n      robot\n            new-robot (cond\n                        (= instr \\R) (turn-right robot)\n                        (= instr \\L) (turn-left robot)\n                        (= instr \\A) (advance robot)\n                        :else robot)]\n        (recur new-robot (rest instrs))))))\n\n(defn turn-right\n  [robot]\n  (update robot :direction #(mod (+ % 1) 4)))\n\n(defn turn-left\n  [robot]\n  (update robot :direction #(mod (- % 1) 4)))\n\n(defn advance\n  [robot]\n  (let [direction (get robot :direction)\n        position (get robot :position)\n        new-position (case direction\n                       0 [(+ (first position) 0) (+ (second position) 1)]\n                       1 [(+ (first position) 1) (+ (second position) 0)]\n                       2 [(+ (first position) 0) (- (second position) 1)]\n                       3 [(- (first position) 1) (+ (second position) 0)])]\n    (assoc robot :position new-position)))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (robot_simulator.clj:17:38).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat robot_simulator_test$eval422$loading__6706__auto____423.invoke(robot_simulator_test.clj:1)\n\tat robot_simulator_test$eval422.invokeStatic(robot_simulator_test.clj:1)\n\tat robot_simulator_test$eval422.invoke(robot_simulator_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init18326412954626583826.clj:1)\n\tat user$eval224.invoke(form-init18326412954626583826.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unmatched delimiter: ]\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1373)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "roman-numerals", "response": "The coder's implementation of the Roman numeral conversion is incorrect. The test results show that the output Roman numerals are not as expected for the given numbers. The output consists of a series of \"X\" characters followed by the expected last character in some cases, which indicates an issue with the logic.\n\nreason: logic\n", "reason": "logic", "tokens": 6183, "instructions": "instructions.md\n# Instructions\n\nWrite a function to convert from normal numbers to Roman Numerals.\n\nThe Romans were a clever bunch. They conquered most of Europe and ruled\nit for hundreds of years. They invented concrete and straight roads and\neven bikinis. One thing they never discovered though was the number\nzero. This made writing and dating extensive histories of their exploits\nslightly more challenging, but the system of numbers they came up with\nis still in use today. For example the BBC uses Roman numerals to date\ntheir programmes.\n\nThe Romans wrote numbers using letters - I, V, X, L, C, D, M. (notice\nthese letters have lots of straight lines and are hence easy to hack\ninto stone tablets).\n\n```text\n 1  => I\n10  => X\n 7  => VII\n```\n\nThere is no need to be able to convert numbers larger than about 3000.\n(The Romans themselves didn't tend to go any higher)\n\nWikipedia says: Modern Roman numerals ... are written by expressing each\ndigit separately starting with the left most digit and skipping any\ndigit with a value of zero.\n\nTo see this in practice, consider the example of 1990.\n\nIn Roman numerals 1990 is MCMXC:\n\n1000=M\n900=CM\n90=XC\n\n2008 is written as MMVIII:\n\n2000=MM\n8=VIII\n\nSee also: http://www.novaroma.org/via_romana/numbers.html\n\n", "code": "roman_numerals.clj\n(ns roman-numerals)\n(def roman-numerals-map\n  {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"})\n\n(defn numerals [number]\n  (loop [remaining-number number\n         roman-numeral \"\"]\n    (if (zero? remaining-number)\n      roman-numeral\n      (let [[value symbol] (first (filter #(<= (key %) remaining-number) (reverse roman-numerals-map)))]\n        (recur (- remaining-number value) (str roman-numeral symbol))))))\n", "test-output": "test_output.txt\n\nlein test roman-numerals-test\n\nlein test :only roman-numerals-test/five-hundred-seventy-five\n\nFAIL in (five-hundred-seventy-five) (roman_numerals_test.clj:48)\nexpected: (= \"DLXXV\" (roman-numerals/numerals 575))\n  actual: (not (= \"DLXXV\" \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXV\"))\n\nlein test :only roman-numerals-test/one-hundred-forty-one\n\nFAIL in (one-hundred-forty-one) (roman_numerals_test.clj:39)\nexpected: (= \"CXLI\" (roman-numerals/numerals 141))\n  actual: (not (= \"CXLI\" \"XXXXXXXXXXXXXXI\"))\n\nlein test :only roman-numerals-test/four-hundred-two\n\nFAIL in (four-hundred-two) (roman_numerals_test.clj:45)\nexpected: (= \"CDII\" (roman-numerals/numerals 402))\n  actual: (not (= \"CDII\" \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXII\"))\n\nlein test :only roman-numerals-test/one-hundred-sixty-three\n\nFAIL in (one-hundred-sixty-three) (roman_numerals_test.clj:42)\nexpected: (= \"CLXIII\" (roman-numerals/numerals 163))\n  actual: (not (= \"CLXIII\" \"XXXXXXXXXXXXXXXXIII\"))\n\nlein test :only roman-numerals-test/nine-hundred-eleven\n\nFAIL in (nine-hundred-eleven) (roman_numerals_test.clj:51)\nexpected: (= \"CMXI\" (roman-numerals/numerals 911))\n  actual: (not (= \"CMXI\" \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXI\"))\n\nlein test :only roman-numerals-test/ninety-three\n\nFAIL in (ninety-three) (roman_numerals_test.clj:36)\nexpected: (= \"XCIII\" (roman-numerals/numerals 93))\n  actual: (not (= \"XCIII\" \"XXXXXXXXXIII\"))\n\nlein test :only roman-numerals-test/three-thousand\n\nFAIL in (three-thousand) (roman_numerals_test.clj:57)\nexpected: (= \"MMM\" (roman-numerals/numerals 3000))\n  actual: (not (= \"MMM\" \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"))\n\nlein test :only roman-numerals-test/nine\n\nFAIL in (nine) (roman_numerals_test.clj:24)\nexpected: (= \"IX\" (roman-numerals/numerals 9))\n  actual: (not (= \"IX\" \"VIV\"))\n\nlein test :only roman-numerals-test/one-thousand-twenty-four\n\nFAIL in (one-thousand-twenty-four) (roman_numerals_test.clj:54)\nexpected: (= \"MXXIV\" (roman-numerals/numerals 1024))\n  actual: (not (= \"MXXIV\" \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXIV\"))\n\nlein test :only roman-numerals-test/fifty-nine\n\nFAIL in (fifty-nine) (roman_numerals_test.clj:33)\nexpected: (= \"LIX\" (roman-numerals/numerals 59))\n  actual: (not (= \"LIX\" \"XXXXXVIV\"))\n\nlein test :only roman-numerals-test/forty-eight\n\nFAIL in (forty-eight) (roman_numerals_test.clj:30)\nexpected: (= \"XLVIII\" (roman-numerals/numerals 48))\n  actual: (not (= \"XLVIII\" \"XXXXVIII\"))\n\nRan 18 tests containing 18 assertions.\n11 failures, 0 errors.\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "rotational-cipher", "tokens": 1935, "instructions": "instructions.md\n# Instructions\n\nCreate an implementation of the rotational cipher, also sometimes called the Caesar cipher.\n\nThe Caesar cipher is a simple shift cipher that relies on transposing all the letters in the alphabet using an integer key between `0` and `26`.\nUsing a key of `0` or `26` will always yield the same output due to modular arithmetic.\nThe letter is shifted for as many values as the value of the key.\n\nThe general notation for rotational ciphers is `ROT + <key>`.\nThe most commonly used rotational cipher is `ROT13`.\n\nA `ROT13` on the Latin alphabet would be as follows:\n\n```text\nPlain:  abcdefghijklmnopqrstuvwxyz\nCipher: nopqrstuvwxyzabcdefghijklm\n```\n\nIt is stronger than the Atbash cipher because it has 27 possible keys, and 25 usable keys.\n\nCiphertext is written out in the same formatting as the input including spaces and punctuation.\n\n## Examples\n\n- ROT5  `omg` gives `trl`\n- ROT0  `c` gives `c`\n- ROT26 `Cool` gives `Cool`\n- ROT13 `The quick brown fox jumps over the lazy dog.` gives `Gur dhvpx oebja sbk whzcf bire gur ynml qbt.`\n- ROT13 `Gur dhvpx oebja sbk whzcf bire gur ynml qbt.` gives `The quick brown fox jumps over the lazy dog.`\n\n", "code": "rotational_cipher.clj\n(ns rotational-cipher)\n\n(defn rotate [text key]\n  (apply str\n         (map (fn [c]\n                (cond\n                  (Character/isUpperCase c)\n                  (char (+ (mod (+ (- (int c) (int \\A)) key) 26) (int \\A)))\n\n                  (Character/isLowerCase c)\n                  (char (+ (mod (+ (- (int c) (int \\a)) key) 26) (int \\a)))\n\n                  :else c))\n              text)))\n", "test-output": "test_output.txt\n\nlein test rotational-cipher-test\n\nRan 10 tests containing 10 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": true, "test": "run-length-encoding", "tokens": 4703, "instructions": "instructions.md\n# Instructions\n\nImplement run-length encoding and decoding.\n\nRun-length encoding (RLE) is a simple form of data compression, where runs\n(consecutive data elements) are replaced by just one data value and count.\n\nFor example we can represent the original 53 characters with only 13.\n\n```text\n\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB\"  ->  \"12WB12W3B24WB\"\n```\n\nRLE allows the original data to be perfectly reconstructed from\nthe compressed data, which makes it a lossless data compression.\n\n```text\n\"AABCCCDEEEE\"  ->  \"2AB3CD4E\"  ->  \"AABCCCDEEEE\"\n```\n\nFor simplicity, you can assume that the unencoded string will only contain\nthe letters A through Z (either lower or upper case) and whitespace. This way\ndata to be encoded will never contain any numbers and numbers inside data to\nbe decoded always represent the count for the following character.\n\n", "code": "run_length_encoding.clj\n(ns run-length-encoding)\n\n(defn run-length-encode\n  \"encodes a string with run-length-encoding\"\n  [plain-text]\n  (->> (partition-by identity plain-text)\n       (map (fn [run]\n              (let [count (count run)\n                    char (first run)]\n                (if (= count 1)\n                  (str char)\n                  (str count char)))))\n       (apply str)))\n\n(defn run-length-decode\n  \"decodes a run-length-encoded string\"\n  [cipher-text]\n  (->> (re-seq #\"(?:\\d+\\D|\\D)\" cipher-text)\n       (map (fn [group]\n              (if (re-matches #\"\\d+\\D\" group)\n                (apply str (repeat (Integer/parseInt (re-find #\"\\d+\" group)) (re-find #\"\\D\" group)))\n                group)))\n       (apply str)))\n", "test-output": "test_output.txt\n\nlein test run-length-encoding-test\n\nRan 13 tests containing 13 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "say", "response": "The coder failed the test because there is a duplicated code block in the middle of the code, causing a syntax error that prevents the code from being compiled.\n\nreason: duplication\n", "reason": "duplication", "tokens": 6554, "instructions": "instructions.md\n# Instructions\n\nGiven a number from 0 to 999,999,999,999, spell out that number in English.\n\n## Step 1\n\nHandle the basic case of 0 through 99.\n\nIf the input to the program is `22`, then the output should be\n`'twenty-two'`.\n\nYour program should complain loudly if given a number outside the\nblessed range.\n\nSome good test cases for this program are:\n\n- 0\n- 14\n- 50\n- 98\n- -1\n- 100\n\n### Extension\n\nIf you're on a Mac, shell out to Mac OS X's `say` program to talk out\nloud. If you're on Linux or Windows, eSpeakNG may be available with the command `espeak`.\n\n## Step 2\n\nImplement breaking a number up into chunks of thousands.\n\nSo `1234567890` should yield a list like 1, 234, 567, and 890, while the\nfar simpler `1000` should yield just 1 and 0.\n\nThe program must also report any values that are out of range.\n\n## Step 3\n\nNow handle inserting the appropriate scale word between those chunks.\n\nSo `1234567890` should yield `'1 billion 234 million 567 thousand 890'`\n\nThe program must also report any values that are out of range.  It's\nfine to stop at \"trillion\".\n\n## Step 4\n\nPut it all together to get nothing but plain English.\n\n`12345` should give `twelve thousand three hundred forty-five`.\n\nThe program must also report any values that are out of range.\n\n### Extensions\n\nUse _and_ (correctly) when spelling out the number in English:\n\n- 14 becomes \"fourteen\".\n- 100 becomes \"one hundred\".\n- 120 becomes \"one hundred and twenty\".\n- 1002 becomes \"one thousand and two\".\n- 1323 becomes \"one thousand three hundred and twenty-three\".\n\n", "code": "say.clj\n(ns say)\n\n(defn number [num]\n  (let [ones [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"]\n        teens [\"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\"]\n        tens [\"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"]\n        scales [\"thousand\" \"million\" \"billion\"]\n        num-to-words (fn [n]\n          (cond\n            (< n 0) (str \"negative \" (num-to-words (- n)))\n            (< n 10) (ones n)\n            (< n 20) (teens (- n 10))\n            (< n 100) (str (tens (quot (- n 20) 10)) (if (mod n 10) (str \"-\" (ones (mod n 10))) \"\"))\n            (< n 1000) (str (ones (quot n 100)) \" hundred\" (if (mod n 100) (str \" and \" (num-to-words (mod n 100))) \"\"))\n            :else (loop [remaining n\n                         scale 0\n                         result \"\"]\n                   (if (< remaining 1000)\n                     (str result (num-to-words remaining))\n                     (recur (quot remaining 1000)\n                            (inc scale)\n                            (str result (num-to-words (mod remaining 1000)) \" \" (scales scale) \" \"))))))]\n  (if (<= 0 num 999999999999)\n    (num-to-words num)\n    (throw (IllegalArgumentException. \"Number out of range\"))))\n        tens [\"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"]\n        scales [\"thousand\" \"million\" \"billion\"]\n        (defn num-to-words [n]\n          (cond\n            (< n 0) (str \"negative \" (num-to-words (- n)))\n            (< n 10) (ones n)\n            (< n 20) (teens (- n 10))\n            (< n 100) (str (tens (quot (- n 20) 10)) (if (mod n 10) (str \"-\" (ones (mod n 10))) \"\"))\n            (< n 1000) (str (ones (quot n 100)) \" hundred\" (if (mod n 100) (str \" and \" (num-to-words (mod n 100))) \"\"))\n            :else (loop [remaining n\n                         scale 0\n                         result \"\"]\n                   (if (< remaining 1000)\n                     (str result (num-to-words remaining))\n                     (recur (quot remaining 1000)\n                            (inc scale)\n                            (str result (num-to-words (mod remaining 1000)) \" \" (scales scale) \" \"))))))]\n  (if (<= 0 num 999999999999)\n    (num-to-words num)\n    (throw (IllegalArgumentException. \"Number out of range\"))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (say.clj:42:106).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat say_test$eval422$loading__6706__auto____423.invoke(say_test.clj:1)\n\tat say_test$eval422.invokeStatic(say_test.clj:1)\n\tat say_test$eval422.invoke(say_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init1003549162010442072.clj:1)\n\tat user$eval224.invoke(form-init1003549162010442072.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: Unmatched delimiter: ]\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1373)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1398)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "scrabble-score", "tokens": 2107, "instructions": "instructions.md\n# Instructions\n\nGiven a word, compute the Scrabble score for that word.\n\n## Letter Values\n\nYou'll need these:\n\n```text\nLetter                           Value\nA, E, I, O, U, L, N, R, S, T       1\nD, G                               2\nB, C, M, P                         3\nF, H, V, W, Y                      4\nK                                  5\nJ, X                               8\nQ, Z                               10\n```\n\n## Examples\n\n\"cabbage\" should be scored as worth 14 points:\n\n- 3 points for C\n- 1 point for A, twice\n- 3 points for B, twice\n- 2 points for G\n- 1 point for E\n\nAnd to total:\n\n- `3 + 2*1 + 2*3 + 2 + 1`\n- = `3 + 2 + 6 + 3`\n- = `5 + 9`\n- = 14\n\n## Extensions\n\n- You can play a double or a triple letter.\n- You can play a double or a triple word.\n\n", "code": "scrabble_score.clj\n(ns scrabble-score)\n\n(defn score-letter [letter]\n  (let [letter-upper (clojure.string/upper-case letter)]\n    (cond\n      (contains? #{\"A\" \"E\" \"I\" \"O\" \"U\" \"L\" \"N\" \"R\" \"S\" \"T\"} letter-upper) 1\n      (contains? #{\"D\" \"G\"} letter-upper) 2\n      (contains? #{\"B\" \"C\" \"M\" \"P\"} letter-upper) 3\n      (contains? #{\"F\" \"H\" \"V\" \"W\" \"Y\"} letter-upper) 4\n      (= \"K\" letter-upper) 5\n      (contains? #{\"J\" \"X\"} letter-upper) 8\n      (contains? #{\"Q\" \"Z\"} letter-upper) 10\n      :else 0)))\n\n(defn score-word [word]\n  (reduce (fn [total-score letter] (+ total-score (score-letter letter))) 0 word))\n", "test-output": "test_output.txt\n\nlein test scrabble-score-test\n\nRan 6 tests containing 6 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "secret-handshake", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 5228, "instructions": "instructions.md\n# Instructions\n\nYour task is to convert a number between 1 and 31 to a sequence of actions in the secret handshake.\n\nThe sequence of actions is chosen by looking at the rightmost five digits of the number once it's been converted to binary.\nStart at the right-most digit and move left.\n\nThe actions for each number place are:\n\n```plaintext\n00001 = wink\n00010 = double blink\n00100 = close your eyes\n01000 = jump\n10000 = Reverse the order of the operations in the secret handshake.\n```\n\nLet's use the number `9` as an example:\n\n- 9 in binary is `1001`.\n- The digit that is farthest to the right is 1, so the first action is `wink`.\n- Going left, the next digit is 0, so there is no double-blink.\n- Going left again, the next digit is 0, so you leave your eyes open.\n- Going left again, the next digit is 1, so you jump.\n\nThat was the last digit, so the final code is:\n\n```plaintext\nwink, jump\n```\n\nGiven the number 26, which is `11010` in binary, we get the following actions:\n\n- double blink\n- jump\n- reverse actions\n\nThe secret handshake for 26 is therefore:\n\n```plaintext\njump, double blink\n```\n\n~~~~exercism/note\nIf you aren't sure what binary is or how it works, check out [this binary tutorial][intro-to-binary].\n[intro-to-binary]: https://medium.com/basecs/bits-bytes-building-with-binary-13cb4289aafa\n~~~~\n\nintroduction.md\n# Introduction\n\nYou are starting a secret coding club with some friends and friends-of-friends.\nNot everyone knows each other, so you and your friends have decided to create a secret handshake that you can use to recognize that someone is a member.\nYou don't want anyone who isn't in the know to be able to crack the code.\n\nYou've designed the code so that one person says a number between 1 and 31, and the other person turns it into a series of actions.\n\n", "code": "secret_handshake.clj\n(ns secret-handshake)\n\n(defn commands [number]\n  (let [binary (apply str (reverse (take 5 (concat (map #(if (= % 1) \"1\" \"0\") (reverse (Integer/toBinaryString number))) (repeat \"0\")))))\n        actions (keep (fn [digit action] (when (= digit \\1) action)) binary [\"wink\" \"double blink\" \"close your eyes\" \"jump\"])]\n    (if (= (first binary) \\1) (reverse actions) actions)))\n", "test-output": "test_output.txt\n\nlein test secret-handshake-test\n\nlein test :only secret-handshake-test/close-your-eyes\n\nERROR in (close-your-eyes) (AFn.java:429)\na close your eyes is returned for a binary 100\nexpected: (= [\"close your eyes\"] (secret-handshake/commands 4))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__456.invokeStatic (secret_handshake_test.clj:15)\n    secret_handshake_test/fn (secret_handshake_test.clj:13)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/reversing-one-action\n\nERROR in (reversing-one-action) (AFn.java:429)\nreversing one action returns the same action\nexpected: (= [\"jump\"] (secret-handshake/commands 24))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__476.invokeStatic (secret_handshake_test.clj:31)\n    secret_handshake_test/fn (secret_handshake_test.clj:29)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/lower-5-bits-zero\n\nERROR in (lower-5-bits-zero) (AFn.java:429)\ndo nothing for high numbers if lower 5 bits not set\nexpected: (= [] (secret-handshake/commands 32))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__501.invokeStatic (secret_handshake_test.clj:55)\n    secret_handshake_test/fn (secret_handshake_test.clj:53)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/jump\n\nERROR in (jump) (AFn.java:429)\na jump is returned for a binary 1000\nexpected: (= [\"jump\"] (secret-handshake/commands 8))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__461.invokeStatic (secret_handshake_test.clj:19)\n    secret_handshake_test/fn (secret_handshake_test.clj:17)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/nothing\n\nERROR in (nothing) (AFn.java:429)\ndo nothing for 0\nexpected: (= [] (secret-handshake/commands 0))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__496.invokeStatic (secret_handshake_test.clj:51)\n    secret_handshake_test/fn (secret_handshake_test.clj:49)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/wink\n\nERROR in (wink) (AFn.java:429)\na wink is returned for binary 1\nexpected: (= [\"wink\"] (secret-handshake/commands 1))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__446.invokeStatic (secret_handshake_test.clj:7)\n    secret_handshake_test/fn (secret_handshake_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/reverse-all-actions\n\nERROR in (reverse-all-actions) (AFn.java:429)\nreversing all actions together\nexpected: (= [\"jump\" \"close your eyes\" \"double blink\" \"wink\"] (secret-handshake/commands 31))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__491.invokeStatic (secret_handshake_test.clj:47)\n    secret_handshake_test/fn (secret_handshake_test.clj:43)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/reverse-nothing\n\nERROR in (reverse-nothing) (AFn.java:429)\nreversing nothing still gives nothing\nexpected: (= [] (secret-handshake/commands 16))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__481.invokeStatic (secret_handshake_test.clj:35)\n    secret_handshake_test/fn (secret_handshake_test.clj:33)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/reversing\n\nERROR in (reversing) (AFn.java:429)\ngiving a binary 10000 reverses actions\nexpected: (= [\"double blink\" \"wink\"] (secret-handshake/commands 19))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__471.invokeStatic (secret_handshake_test.clj:27)\n    secret_handshake_test/fn (secret_handshake_test.clj:25)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/double-blink\n\nERROR in (double-blink) (AFn.java:429)\na double blink is returned for a binary 10\nexpected: (= [\"double blink\"] (secret-handshake/commands 2))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__451.invokeStatic (secret_handshake_test.clj:11)\n    secret_handshake_test/fn (secret_handshake_test.clj:9)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/two-actions\n\nERROR in (two-actions) (AFn.java:429)\ncommands returns multiple actions\nexpected: (= [\"wink\" \"double blink\"] (secret-handshake/commands 3))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__466.invokeStatic (secret_handshake_test.clj:23)\n    secret_handshake_test/fn (secret_handshake_test.clj:21)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only secret-handshake-test/all-actions\n\nERROR in (all-actions) (AFn.java:429)\nall actions together\nexpected: (= [\"wink\" \"double blink\" \"close your eyes\" \"jump\"] (secret-handshake/commands 15))\n  actual: clojure.lang.ArityException: Wrong number of args (3) passed to: clojure.core/keep\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:40)\n    secret_handshake$commands.invokeStatic (secret_handshake.clj:5)\n    secret_handshake$commands.invoke (secret_handshake.clj:3)\n    secret_handshake_test$fn__486.invokeStatic (secret_handshake_test.clj:41)\n    secret_handshake_test/fn (secret_handshake_test.clj:37)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init12025260451064375305.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init12025260451064375305.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init12025260451064375305.clj:1)\n    user$eval224$fn__357.invoke (form-init12025260451064375305.clj:1)\n    user$eval224.invokeStatic (form-init12025260451064375305.clj:1)\n    user$eval224.invoke (form-init12025260451064375305.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 12 tests containing 12 assertions.\n0 failures, 12 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "series", "response": "The coder failed the test because the logic for handling the case when the length is 0 is incorrect. Instead of returning a single empty string in a vector, it returns multiple empty strings.\n\nreason: logic\n", "reason": "logic", "tokens": 4401, "instructions": "instructions.md\n# Instructions\n\nGiven a string of digits, output all the contiguous substrings of length `n` in\nthat string in the order that they appear.\n\nFor example, the string \"49142\" has the following 3-digit series:\n\n- \"491\"\n- \"914\"\n- \"142\"\n\nAnd the following 4-digit series:\n\n- \"4914\"\n- \"9142\"\n\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve\nwhatever you get.\n\nNote that these series are only required to occupy *adjacent positions*\nin the input; the digits need not be *numerically consecutive*.\n\n", "code": "series.clj\n(ns series)\n\n(defn slices [string length]\n  (if (<= length (count string))\n    (map (fn [i] (subs string i (+ i length)))\n         (range 0 (- (count string) length -1)))\n    []))\n", "test-output": "test_output.txt\n\nlein test series-test\n\nlein test :only series-test/number-eq-zero\n\nFAIL in (number-eq-zero) (series_test.clj:11)\nnumber = 0\nexpected: (= [\"\"] (slices \"123\" 0))\n  actual: (not (= [\"\"] (\"\" \"\" \"\" \"\")))\n\nRan 5 tests containing 5 assertions.\n1 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "sieve", "response": "The coder failed the test because there is a syntax error in their code. The error message \"EOF while reading, starting at line 3\" indicates that there is a missing or misplaced parenthesis, bracket, or other delimiter in the code.\n\nreason: syntax\n", "reason": "syntax", "tokens": 5291, "instructions": "instructions.md\n# Instructions\n\nYour task is to create a program that implements the Sieve of Eratosthenes algorithm to find prime numbers.\n\nA prime number is a number that is only divisible by 1 and itself.\nFor example, 2, 3, 5, 7, 11, and 13 are prime numbers.\n\nThe Sieve of Eratosthenes is an ancient algorithm that works by taking a list of numbers and crossing out all the numbers that aren't prime.\n\nA number that is **not** prime is called a \"composite number\".\n\nTo use the Sieve of Eratosthenes, you first create a list of all the numbers between 2 and your given number.\nThen you repeat the following steps:\n\n1. Find the next unmarked number in your list. This is a prime number.\n2. Mark all the multiples of that prime number as composite (not prime).\n\nYou keep repeating these steps until you've gone through every number in your list.\nAt the end, all the unmarked numbers are prime.\n\n~~~~exercism/note\n[Wikipedia's Sieve of Eratosthenes article][eratosthenes] has a useful graphic that explains the algorithm.\n\nThe tests don't check that you've implemented the algorithm, only that you've come up with the correct list of primes.\nA good first test is to check that you do not use division or remainder operations.\n\n[eratosthenes]: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n~~~~\n\nintroduction.md\n# Introduction\n\nYou bought a big box of random computer parts at a garage sale.\nYou've started putting the parts together to build custom computers.\n\nYou want to test the performance of different combinations of parts, and decide to create your own benchmarking program to see how your computers compare.\nYou choose the famous \"Sieve of Eratosthenes\" algorithm, an ancient algorithm, but one that should push your computers to the limits.\n\n", "code": "sieve.clj\n(ns sieve)\n\n(defn sieve [n]\n  (let [sieve-range (vec (repeat (+ n 1) true))\n        sqrt-n (int (Math/sqrt n))]\n    (doseq [i (range 2 (+ sqrt-n 1))]\n      (when (sieve-range i)\n        (doseq [j (range (* i i) (+ n 1) i)]\n          (aset sieve-range j false))))\n    (filterv #(sieve-range %) (range 2 (+ n 1))))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error reading source at (sieve.clj:11:1).\n\tat clojure.lang.Compiler.load(Compiler.java:7642)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat sieve_test$eval422$loading__6706__auto____423.invoke(sieve_test.clj:1)\n\tat sieve_test$eval422.invokeStatic(sieve_test.clj:1)\n\tat sieve_test$eval422.invoke(sieve_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init2915479216359021129.clj:1)\n\tat user$eval224.invoke(form-init2915479216359021129.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.RuntimeException: EOF while reading, starting at line 3\n\tat clojure.lang.Util.runtimeException(Util.java:221)\n\tat clojure.lang.LispReader.readDelimitedList(LispReader.java:1405)\n\tat clojure.lang.LispReader$ListReader.invoke(LispReader.java:1243)\n\tat clojure.lang.LispReader.read(LispReader.java:285)\n\tat clojure.lang.LispReader.read(LispReader.java:216)\n\tat clojure.lang.Compiler.load(Compiler.java:7630)\n\t... 69 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "space-age", "response": "The coder implemented the functions to calculate the age on different planets correctly. However, the test suite timed out, which means the test cases took too long to execute. This could be due to an issue with the test suite itself or an issue with the code causing infinite loops or excessive computation.\n\nreason: other\n", "reason": "other", "tokens": 6268, "instructions": "instructions.md\n# Instructions\n\nGiven an age in seconds, calculate how old someone would be on:\n\n   - Mercury: orbital period 0.2408467 Earth years\n   - Venus: orbital period 0.61519726 Earth years\n   - Earth: orbital period 1.0 Earth years, 365.25 Earth days, or 31557600 seconds\n   - Mars: orbital period 1.8808158 Earth years\n   - Jupiter: orbital period 11.862615 Earth years\n   - Saturn: orbital period 29.447498 Earth years\n   - Uranus: orbital period 84.016846 Earth years\n   - Neptune: orbital period 164.79132 Earth years\n\nSo if you were told someone were 1,000,000,000 seconds old, you should\nbe able to say that they're 31.69 Earth-years old.\n\nIf you're wondering why Pluto didn't make the cut, go watch [this\nyoutube video](http://www.youtube.com/watch?v=Z_2gbGXzFbs).\n\n", "code": "space_age.clj\n(ns space-age)\n\n(def EARTH_SECONDS 31557600)\n\n(defn age-on-planet [seconds orbital-period]\n  (/ seconds (* EARTH_SECONDS orbital-period)))\n\n(defn on-mercury [seconds]\n  (age-on-planet seconds 0.2408467))\n\n(defn on-venus [seconds]\n  (age-on-planet seconds 0.61519726))\n\n(defn on-earth [seconds]\n  (age-on-planet seconds 1.0))\n\n(defn on-mars [seconds]\n  (age-on-planet seconds 1.8808158))\n\n(defn on-jupiter [seconds]\n  (age-on-planet seconds 11.862615))\n\n(defn on-saturn [seconds]\n  (age-on-planet seconds 29.447498))\n\n(defn on-uranus [seconds]\n  (age-on-planet seconds 84.016846))\n\n(defn on-neptune [seconds]\n  (age-on-planet seconds 164.79132))\n", "test-output": "test_output.txt\nTest timed out"},{"iterations": 2, "passed": false, "test": "spiral-matrix", "response": "The coder failed the test because the code throws an IndexOutOfBoundsException when trying to update the matrix. The logic for checking the next position and updating the direction is incorrect, causing the code to attempt to access invalid indices.\n\nreason: logic\n", "reason": "logic", "tokens": 5053, "instructions": "instructions.md\n# Instructions\n\nGiven the size, return a square matrix of numbers in spiral order.\n\nThe matrix should be filled with natural numbers, starting from 1\nin the top-left corner, increasing in an inward, clockwise spiral order,\nlike these examples:\n\n## Examples\n### Spiral matrix of size 3\n\n```text\n1 2 3\n8 9 4\n7 6 5\n```\n\n### Spiral matrix of size 4\n\n```text\n 1  2  3 4\n12 13 14 5\n11 16 15 6\n10  9  8 7\n```\n\n", "code": "spiral_matrix.clj\n(ns spiral-matrix)\n\n(defn spiral [n]\n  (let [matrix (vec (mapv vec (repeat n (repeat n 0))))\n        directions [[0 1] [1 0] [0 -1] [-1 0]]\n        step (fn [pos dir] (map + pos dir))]\n    (loop [pos [0 0]\n           dir 0\n           num 1\n           matrix matrix]\n      (if (> num (* n n))\n        matrix\n        (let [updated-matrix (assoc-in matrix pos num)\n              next-pos (step pos (directions dir))\n              next-dir (if (and (every? #(<= 0 % (dec n)) next-pos)\n                                (= 0 (get-in updated-matrix next-pos)))\n                          dir\n                          (mod (inc dir) 4))]\n          (recur next-pos next-dir (inc num) updated-matrix))))))\n", "test-output": "test_output.txt\n\nlein test spiral-matrix-test\n\nlein test :only spiral-matrix-test/spiral-matrix-of-2\n\nFAIL in (spiral-matrix-of-2) (spiral_matrix_test.clj:17)\nspiral matrix of 2\nexpected: (= (spiral 2) (quote ((1 2) (4 3))))\n  actual: (not (= [[1 2 3] [0 0 4]] ((1 2) (4 3))))\n\nlein test :only spiral-matrix-test/spiral-matrix-of-4\n\nERROR in (spiral-matrix-of-4) (PersistentVector.java:188)\nspiral matrix of 4\nexpected: (= (spiral 4) (quote ((1 2 3 4) (12 13 14 5) (11 16 15 6) (10 9 8 7))))\n  actual: java.lang.IndexOutOfBoundsException: null\n at clojure.lang.PersistentVector.assocN (PersistentVector.java:188)\n    clojure.lang.PersistentVector.assocN (PersistentVector.java:22)\n    clojure.lang.APersistentVector.assoc (APersistentVector.java:345)\n    clojure.lang.APersistentVector.assoc (APersistentVector.java:18)\n    clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core$assoc_in.invokeStatic (core.clj:6169)\n    clojure.core$assoc_in.invokeStatic (core.clj:6169)\n    clojure.core$assoc_in.invoke (core.clj:6161)\n    spiral_matrix$spiral.invokeStatic (spiral_matrix.clj:13)\n    spiral_matrix$spiral.invoke (spiral_matrix.clj:3)\n    spiral_matrix_test$fn__469.invokeStatic (spiral_matrix_test.clj:30)\n    spiral_matrix_test/fn (spiral_matrix_test.clj:28)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init452453399102828583.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init452453399102828583.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init452453399102828583.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init452453399102828583.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init452453399102828583.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init452453399102828583.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init452453399102828583.clj:1)\n    user$eval224$fn__357.invoke (form-init452453399102828583.clj:1)\n    user$eval224.invokeStatic (form-init452453399102828583.clj:1)\n    user$eval224.invoke (form-init452453399102828583.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only spiral-matrix-test/spiral-matrix-of-20\n\nERROR in (spiral-matrix-of-20) (PersistentVector.java:188)\nspiral matrix of 20\nexpected: (= (spiral 20) (quote ((1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20) (76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 21) (75 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 95 22) (74 143 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 161 96 23) (73 142 203 256 257 258 259 260 261 262 263 264 265 266 267 268 219 162 97 24) (72 141 202 255 300 301 302 303 304 305 306 307 308 309 310 269 220 163 98 25) (71 140 201 254 299 336 337 338 339 340 341 342 343 344 311 270 221 164 99 26) (70 139 200 253 298 335 364 365 366 367 368 369 370 345 312 271 222 165 100 27) (69 138 199 252 297 334 363 384 385 386 387 388 371 346 313 272 223 166 101 28) (68 137 198 251 296 333 362 383 396 397 398 389 372 347 314 273 224 167 102 29) (67 136 197 250 295 332 361 382 395 400 399 390 373 348 315 274 225 168 103 30) (66 135 196 249 294 331 360 381 394 393 392 391 374 349 316 275 226 169 104 31) (65 134 195 248 293 330 359 380 379 378 377 376 375 350 317 276 227 170 105 32) (64 133 194 247 292 329 358 357 356 355 354 353 352 351 318 277 228 171 106 33) (63 132 193 246 291 328 327 326 325 324 323 322 321 320 319 278 229 172 107 34) (62 131 192 245 290 289 288 287 286 285 284 283 282 281 280 279 230 173 108 35) (61 130 191 244 243 242 241 240 239 238 237 236 235 234 233 232 231 174 109 36) (60 129 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176 175 110 37) (59 128 127 126 125 124 123 122 121 120 119 118 117 116 115 114 113 112 111 38) (58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39))))\n  actual: java.lang.IndexOutOfBoundsException: null\n at clojure.lang.PersistentVector.assocN (PersistentVector.java:188)\n    clojure.lang.PersistentVector.assocN (PersistentVector.java:22)\n    clojure.lang.APersistentVector.assoc (APersistentVector.java:345)\n    clojure.lang.APersistentVector.assoc (APersistentVector.java:18)\n    clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core$assoc_in.invokeStatic (core.clj:6169)\n    clojure.core$assoc_in.invokeStatic (core.clj:6169)\n    clojure.core$assoc_in.invoke (core.clj:6161)\n    spiral_matrix$spiral.invokeStatic (spiral_matrix.clj:13)\n    spiral_matrix$spiral.invoke (spiral_matrix.clj:3)\n    spiral_matrix_test$fn__474.invokeStatic (spiral_matrix_test.clj:38)\n    spiral_matrix_test/fn (spiral_matrix_test.clj:36)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init452453399102828583.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init452453399102828583.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init452453399102828583.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init452453399102828583.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init452453399102828583.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init452453399102828583.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init452453399102828583.clj:1)\n    user$eval224$fn__357.invoke (form-init452453399102828583.clj:1)\n    user$eval224.invokeStatic (form-init452453399102828583.clj:1)\n    user$eval224.invoke (form-init452453399102828583.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only spiral-matrix-test/spiral-matrix-of-3\n\nERROR in (spiral-matrix-of-3) (PersistentVector.java:188)\nspiral matrix of 3\nexpected: (= (spiral 3) (quote ((1 2 3) (8 9 4) (7 6 5))))\n  actual: java.lang.IndexOutOfBoundsException: null\n at clojure.lang.PersistentVector.assocN (PersistentVector.java:188)\n    clojure.lang.PersistentVector.assocN (PersistentVector.java:22)\n    clojure.lang.APersistentVector.assoc (APersistentVector.java:345)\n    clojure.lang.APersistentVector.assoc (APersistentVector.java:18)\n    clojure.lang.RT.assoc (RT.java:823)\n    clojure.core$assoc__5401.invokeStatic (core.clj:191)\n    clojure.core$assoc_in.invokeStatic (core.clj:6169)\n    clojure.core$assoc_in.invokeStatic (core.clj:6169)\n    clojure.core$assoc_in.invoke (core.clj:6161)\n    spiral_matrix$spiral.invokeStatic (spiral_matrix.clj:13)\n    spiral_matrix$spiral.invoke (spiral_matrix.clj:3)\n    spiral_matrix_test$fn__464.invokeStatic (spiral_matrix_test.clj:23)\n    spiral_matrix_test/fn (spiral_matrix_test.clj:21)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init452453399102828583.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init452453399102828583.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init452453399102828583.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init452453399102828583.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init452453399102828583.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init452453399102828583.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init452453399102828583.clj:1)\n    user$eval224$fn__357.invoke (form-init452453399102828583.clj:1)\n    user$eval224.invokeStatic (form-init452453399102828583.clj:1)\n    user$eval224.invoke (form-init452453399102828583.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 6 tests containing 6 assertions.\n1 failures, 3 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "strain", "response": "The coder failed the test due to a namespace conflict and an IllegalAccessError. The `keep` function in the code conflicts with the `keep` function in the Clojure core library, causing a warning. Additionally, the test suite is unable to access the `retain` function, causing an IllegalAccessError.\n\nreason: other\n", "reason": "other", "tokens": 3999, "instructions": "instructions.md\n# Instructions\n\nImplement the `keep` and `discard` operation on collections. Given a collection\nand a predicate on the collection's elements, `keep` returns a new collection\ncontaining those elements where the predicate is true, while `discard` returns\na new collection containing those elements where the predicate is false.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the predicate:\n\n- is the number even?\n\nThen your keep operation should produce:\n\n- 2, 4\n\nWhile your discard operation should produce:\n\n- 1, 3, 5\n\nNote that the union of keep and discard is all the elements.\n\nThe functions may be called `keep` and `discard`, or they may need different\nnames in order to not clash with existing functions or concepts in your\nlanguage.\n\n## Restrictions\n\nKeep your hands off that filter/reject/whatchamacallit functionality\nprovided by your standard library!  Solve this one yourself using other\nbasic tools instead.\n\n", "code": "strain.clj\n(ns strain)\n\n(defn keep [coll pred]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (pred (first s))\n        (cons (first s) (keep (rest s) pred))\n        (keep (rest s) pred)))))\n\n(defn discard [coll pred]\n  (keep coll (fn [item] (not (pred item)))))\n", "test-output": "test_output.txt\nWARNING: keep already refers to: #'clojure.core/keep in namespace: strain, being replaced by: #'strain/keep\nException in thread \"main\" Syntax error compiling at (strain_test.clj:1:1).\n\tat clojure.lang.Compiler.load(Compiler.java:7647)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init15974180285243895846.clj:1)\n\tat user$eval224.invoke(form-init15974180285243895846.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.IllegalAccessError: retain does not exist\n\tat clojure.core$refer.invokeStatic(core.clj:4249)\n\tat clojure.core$refer.doInvoke(core.clj:4217)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:139)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5966)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat strain_test$eval422$loading__6706__auto____423.invoke(strain_test.clj:1)\n\tat strain_test$eval422.invokeStatic(strain_test.clj:1)\n\tat strain_test$eval422.invoke(strain_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\t... 41 more\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "sublist", "tokens": 1973, "instructions": "instructions.md\n# Instructions\n\nGiven two lists determine whether :\n- the first list is contained within the second \n- the second list is contained within the first list\n- both lists are equal\n- none of the above, lists are unequal\n\nSpecifically, a list A is a sublist of list B if by dropping 0 or more elements\nfrom the front of B and 0 or more elements from the back of B you get a list\nthat's completely equal to A.\n\n### Rules\n\nDetermine the relation between list1 and list2 and return the relation as a Clojure keyword.\nThe function `classify` should either return `:sublist`, `:superlist`, `:equal` or`:unequal`.\n\n\n### Examples:\n\n * A = [1, 2, 3], B = [1, 2, 3, 4, 5], A is a sublist of B\n * A = [3, 4, 5], B = [1, 2, 3, 4, 5], A is a sublist of B\n * A = [3, 4], B = [1, 2, 3, 4, 5], A is a sublist of B\n * A = [1, 2, 3], B = [1, 2, 3], A is equal to B\n * A = [1, 2, 3, 4, 5], B = [2, 3, 4], A is a superlist of B\n * A = [1, 2, 4], B = [1, 2, 3, 4, 5], A is neither a superlist, sublist nor equal to B : they are unequal\n\n", "code": "sublist.clj\n(ns sublist)\n\n(defn classify [list1 list2]\n  (cond\n    (= list1 list2) :equal\n    (some #(= list1 %) (partition (count list1) 1 list2)) :sublist\n    (some #(= list2 %) (partition (count list2) 1 list1)) :superlist\n    :else :unequal))\n", "test-output": "test_output.txt\n\nlein test sublist-test\n\nRan 18 tests containing 18 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "sum-of-multiples", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 5284, "instructions": "instructions.md\n# Instructions\n\nYour task is to write the code that calculates the energy points that get awarded to players when they complete a level.\n\nThe points awarded depend on two things:\n\n- The level (a number) that the player completed.\n- The base value of each magical item collected by the player during that level.\n\nThe energy points are awarded according to the following rules:\n\n1. For each magical item, take the base value and find all the multiples of that value that are less than the level number.\n2. Combine the sets of numbers.\n3. Remove any duplicates.\n4. Calculate the sum of all the numbers that are left.\n\nLet's look at an example:\n\n**The player completed level 20 and found two magical items with base values of 3 and 5.**\n\nTo calculate the energy points earned by the player, we need to find all the unique multiples of these base values that are less than level 20.\n\n- Multiples of 3 less than 20: `{3, 6, 9, 12, 15, 18}`\n- Multiples of 5 less than 20: `{5, 10, 15}`\n- Combine the sets and remove duplicates: `{3, 5, 6, 9, 10, 12, 15, 18}`\n- Sum the unique multiples: `3 + 5 + 6 + 9 + 10 + 12 + 15 + 18 = 78`\n- Therefore, the player earns **78** energy points for completing level 20 and finding the two magical items with base values of 3 and 5.\n\nintroduction.md\n# Introduction\n\nYou work for a company that makes an online, fantasy-survival game.\n\nWhen a player finishes a level, they are awarded energy points.\nThe amount of energy awarded depends on which magical items the player found while exploring that level.\n\n", "code": "sum_of_multiples.clj\n(ns sum-of-multiples)\n\n(defn sum-of-multiples [level base-values]\n  (let [multiples (->> (seq base-values)\n                       (mapcat #(range % level %))\n                       (distinct))]\n    (reduce + multiples)))\n", "test-output": "test_output.txt\n\nlein test sum-of-multiples-test\n\nlein test :only sum-of-multiples-test/no-multiples\n\nERROR in (no-multiples) (RT.java:553)\nNo multiples within limit\nexpected: (zero? (sum-of-multiples (quote (3 5)) 1))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__444.invokeStatic (sum_of_multiples_test.clj:7)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/all-factors-multiples-of-1\n\nERROR in (all-factors-multiples-of-1) (RT.java:553)\nAll factors are multiples of 1\nexpected: (= 4950 (sum-of-multiples (quote (1)) 100))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__499.invokeStatic (sum_of_multiples_test.clj:51)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:49)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/more-than-one-multiple\n\nERROR in (more-than-one-multiple) (RT.java:553)\nMore than one multiple within limit\nexpected: (= 9 (sum-of-multiples (quote (3)) 7))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__454.invokeStatic (sum_of_multiples_test.clj:15)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:13)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/no-factors\n\nERROR in (no-factors) (RT.java:553)\nNo factors means sum is 0\nexpected: (zero? (sum-of-multiples (quote ()) 10000))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__504.invokeStatic (sum_of_multiples_test.clj:55)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:53)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/larger-limit\n\nERROR in (larger-limit) (RT.java:553)\nA much larger limit\nexpected: (= 233168 (sum-of-multiples (quote (3 5)) 1000))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__469.invokeStatic (sum_of_multiples_test.clj:27)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:25)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/more-than-one-factor-multiples\n\nERROR in (more-than-one-factor-multiples) (RT.java:553)\nMore than one factor with multiples within limit\nexpected: (= 23 (sum-of-multiples (quote (3 5)) 10))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__459.invokeStatic (sum_of_multiples_test.clj:19)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:17)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/count-multiples-once\n\nERROR in (count-multiples-once) (RT.java:553)\nEach multiple is only counted once\nexpected: (= 2318 (sum-of-multiples (quote (3 5)) 100))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__464.invokeStatic (sum_of_multiples_test.clj:23)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:21)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/larger-factors\n\nERROR in (larger-factors) (RT.java:553)\nMuch larger factors\nexpected: (= 2203160 (sum-of-multiples (quote (43 47)) 10000))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__494.invokeStatic (sum_of_multiples_test.clj:47)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:45)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/three-factors\n\nERROR in (three-factors) (RT.java:553)\nThree factors\nexpected: (= 51 (sum-of-multiples (quote (7 13 17)) 20))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__474.invokeStatic (sum_of_multiples_test.clj:31)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:29)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/factor-multiple-of-other-factor\n\nERROR in (factor-multiple-of-other-factor) (RT.java:553)\nOne factor is a multiple of another\nexpected: (= 275 (sum-of-multiples (quote (5 25)) 51))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__489.invokeStatic (sum_of_multiples_test.clj:43)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:41)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/factors-not-relatively-prime\n\nERROR in (factors-not-relatively-prime) (RT.java:553)\nFactors not relatively prime\nexpected: (= 30 (sum-of-multiples (quote (4 6)) 15))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__479.invokeStatic (sum_of_multiples_test.clj:35)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:33)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/more-than-three-factors\n\nERROR in (more-than-three-factors) (RT.java:553)\nMore than 3 factors\nexpected: (= 39614537 (sum-of-multiples (quote (2 3 5 7 11)) 10000))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__509.invokeStatic (sum_of_multiples_test.clj:59)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:57)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/some-factors-relatively-prime\n\nERROR in (some-factors-relatively-prime) (RT.java:553)\nSome pairs of factors relatively prime and some not\nexpected: (= 4419 (sum-of-multiples (quote (5 6 8)) 150))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__484.invokeStatic (sum_of_multiples_test.clj:39)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:37)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only sum-of-multiples-test/one-factor-multiples\n\nERROR in (one-factor-multiples) (RT.java:553)\nOne factor has multiples within limit\nexpected: (= 3 (sum-of-multiples (quote (3 5)) 4))\n  actual: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n at clojure.lang.RT.seqFrom (RT.java:553)\n    clojure.lang.RT.seq (RT.java:533)\n    clojure.core$seq__5387.invokeStatic (core.clj:137)\n    clojure.core/seq (core.clj:137)\n    sum_of_multiples$sum_of_multiples.invokeStatic (sum_of_multiples.clj:4)\n    sum_of_multiples$sum_of_multiples.invoke (sum_of_multiples.clj:3)\n    sum_of_multiples_test$fn__449.invokeStatic (sum_of_multiples_test.clj:11)\n    sum_of_multiples_test/fn (sum_of_multiples_test.clj:9)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init15524820573758473775.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init15524820573758473775.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init15524820573758473775.clj:1)\n    user$eval224$fn__357.invoke (form-init15524820573758473775.clj:1)\n    user$eval224.invokeStatic (form-init15524820573758473775.clj:1)\n    user$eval224.invoke (form-init15524820573758473775.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 14 tests containing 14 assertions.\n0 failures, 14 errors.\nTests failed.\n"},{"iterations": 1, "passed": true, "test": "triangle", "tokens": 2173, "instructions": "instructions.md\n# Instructions\n\nDetermine if a triangle is equilateral, isosceles, or scalene.\n\nAn _equilateral_ triangle has all three sides the same length.\n\nAn _isosceles_ triangle has at least two sides the same length. (It is sometimes\nspecified as having exactly two sides the same length, but for the purposes of\nthis exercise we'll say at least two.)\n\nA _scalene_ triangle has all sides of different lengths.\n\n## Note\n\nFor a shape to be a triangle at all, all sides have to be of length > 0, and\nthe sum of the lengths of any two sides must be greater than or equal to the\nlength of the third side. See [Triangle Inequality](https://en.wikipedia.org/wiki/Triangle_inequality).\n\n## Dig Deeper\n\nThe case where the sum of the lengths of two sides _equals_ that of the\nthird is known as a _degenerate_ triangle - it has zero area and looks like\na single line. Feel free to add your own code/tests to check for degenerate triangles.\n\n", "code": "triangle.clj\n(ns triangle)\n\n(defn is-valid? [a b c]\n  (and (> a 0) (> b 0) (> c 0)\n       (>= (+ a b) c)\n       (>= (+ a c) b)\n       (>= (+ b c) a)))\n\n(defn equilateral? [a b c]\n  (and (is-valid? a b c)\n       (= a b c)))\n\n(defn isosceles? [a b c]\n  (and (is-valid? a b c)\n       (or (= a b) (= a c) (= b c))))\n\n(defn scalene? [a b c]\n  (and (is-valid? a b c)\n       (not (= a b c))\n       (not (or (= a b) (= a c) (= b c)))))\n", "test-output": "test_output.txt\n\nlein test triangle-test\n\nRan 19 tests containing 19 assertions.\n0 failures, 0 errors.\n"},{"iterations": 1, "passed": true, "test": "trinary", "tokens": 1829, "instructions": "instructions.md\n# Instructions\n\nConvert a trinary number, represented as a string (e.g. '102012'), to its\ndecimal equivalent using first principles.\n\nThe program should consider strings specifying an invalid trinary as the\nvalue 0.\n\nTrinary numbers contain three symbols: 0, 1, and 2.\n\nThe last place in a trinary number is the 1's place. The second to last\nis the 3's place, the third to last is the 9's place, etc.\n\n```shell\n# \"102012\"\n    1       0       2       0       1       2    # the number\n1*3^5 + 0*3^4 + 2*3^3 + 0*3^2 + 1*3^1 + 2*3^0    # the value\n  243 +     0 +    54 +     0 +     3 +     2 =  302\n```\n\nIf your language provides a method in the standard library to perform the\nconversion, pretend it doesn't exist and implement it yourself.\n\n", "code": "trinary.clj\n(ns trinary)\n\n(defn to-decimal [trinary-str]\n  (if (re-matches #\"^[0-2]*$\" trinary-str)\n    (reduce\n      (fn [acc value] (+ (* acc 3) (Character/digit value 10)))\n      0\n      trinary-str)\n    0))\n", "test-output": "test_output.txt\n\nlein test trinary-test\n\nRan 10 tests containing 10 assertions.\n0 failures, 0 errors.\n"},{"iterations": 1, "passed": true, "test": "two-fer", "tokens": 1910, "instructions": "instructions.md\n# Instructions\n\nYour task is to determine what you will say as you give away the extra cookie.\n\nIf your friend likes cookies, and is named Do-yun, then you will say:\n\n```text\nOne for Do-yun, one for me.\n```\n\nIf your friend doesn't like cookies, you give the cookie to the next person in line at the bakery.\nSince you don't know their name, you will say _you_ instead.\n\n```text\nOne for you, one for me.\n```\n\nHere are some examples:\n\n|Name    |Dialogue\n|:-------|:------------------\n|Alice   |One for Alice, one for me.\n|Bohdan  |One for Bohdan, one for me.\n|        |One for you, one for me.\n|Zaphod  |One for Zaphod, one for me.\n\nintroduction.md\n# Introduction\n\nIn some English accents, when you say \"two for\" quickly, it sounds like \"two fer\".\nTwo-for-one is a way of saying that if you buy one, you also get one for free.\nSo the phrase \"two-fer\" often implies a two-for-one offer.\n\nImagine a bakery that has a holiday offer where you can buy two cookies for the price of one (\"two-fer one!\").\nYou go for the offer and (very generously) decide to give the extra cookie to a friend.\n\n", "code": "two_fer.clj\n(ns two-fer)\n\n(defn two-fer\n  ([name]\n   (str \"One for \" name \", one for me.\"))\n  ([]\n   (two-fer \"you\")))\n", "test-output": "test_output.txt\n\nlein test two-fer-test\n\nRan 3 tests containing 3 assertions.\n0 failures, 0 errors.\n"},{"iterations": 2, "passed": false, "test": "word-count", "response": "The coder failed the test due to a syntax error in their code. They misplaced the `(:require [clojure.string :as str])` inside the namespace declaration, causing the ClassNotFoundException for clojure.string.\n\nreason: syntax\n", "reason": "syntax", "tokens": 5193, "instructions": "instructions.md\n# Instructions\n\nYour task is to count how many times each word occurs in a subtitle of a drama.\n\nThe subtitles from these dramas use only ASCII characters.\n\nThe characters often speak in casual English, using contractions like _they're_ or _it's_.\nThough these contractions come from two words (e.g. _we are_), the contraction (_we're_) is considered a single word.\n\nWords can be separated by any form of punctuation (e.g. \":\", \"!\", or \"?\") or whitespace (e.g. \"\\t\", \"\\n\", or \" \").\nThe only punctuation that does not separate words is the apostrophe in contractions.\n\nNumbers are considered words.\nIf the subtitles say _It costs 100 dollars._ then _100_ will be its own word.\n\nWords are case insensitive.\nFor example, the word _you_ occurs three times in the following sentence:\n\n> You come back, you hear me? DO YOU HEAR ME?\n\nThe ordering of the word counts in the results doesn't matter.\n\nHere's an example that incorporates several of the elements discussed above:\n\n- simple words\n- contractions\n- numbers\n- case insensitive words\n- punctuation (including apostrophes) to separate words\n- different forms of whitespace to separate words\n\n`\"That's the password: 'PASSWORD 123'!\", cried the Special Agent.\\nSo I fled.`\n\nThe mapping for this subtitle would be:\n\n```text\n123: 1\nagent: 1\ncried: 1\nfled: 1\ni: 1\npassword: 2\nso: 1\nspecial: 1\nthat's: 1\nthe: 2\n```\n\nintroduction.md\n# Introduction\n\nYou teach English as a foreign language to high school students.\n\nYou've decided to base your entire curriculum on TV shows.\nYou need to analyze which words are used, and how often they're repeated.\n\nThis will let you choose the simplest shows to start with, and to gradually increase the difficulty as time passes.\n\n", "code": "word_count.clj\n(ns word-count)\n  (:require [clojure.string :as str])\n\n(defn word-count [s]\n  (->> (str/lower-case s)\n       (str/replace #\"[^\\w']+\" \" \")\n       (str/split #\"\\s+\")\n       (remove str/blank?)\n       (frequencies)))\n", "test-output": "test_output.txt\nException in thread \"main\" Syntax error compiling at (word_count.clj:2:3).\n\tat clojure.lang.Compiler.analyze(Compiler.java:6808)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$VectorExpr.parse(Compiler.java:3260)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6791)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3881)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7108)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6745)\n\tat clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6120)\n\tat clojure.lang.Compiler$FnMethod.parse(Compiler.java:5467)\n\tat clojure.lang.Compiler$FnExpr.parse(Compiler.java:4029)\n\tat clojure.lang.Compiler.analyzeSeq(Compiler.java:7104)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6789)\n\tat clojure.lang.Compiler.eval(Compiler.java:7173)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.invoke(RestFn.java:421)\n\tat word_count_test$eval422$loading__6706__auto____423.invoke(word_count_test.clj:1)\n\tat word_count_test$eval422.invokeStatic(word_count_test.clj:1)\n\tat word_count_test$eval422.invoke(word_count_test.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7165)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.RT.loadResourceScript(RT.java:381)\n\tat clojure.lang.RT.loadResourceScript(RT.java:372)\n\tat clojure.lang.RT.load(RT.java:463)\n\tat clojure.lang.RT.load(RT.java:428)\n\tat clojure.core$load$fn__6824.invoke(core.clj:6126)\n\tat clojure.core$load.invokeStatic(core.clj:6125)\n\tat clojure.core$load.doInvoke(core.clj:6109)\n\tat clojure.lang.RestFn.invoke(RestFn.java:408)\n\tat clojure.core$load_one.invokeStatic(core.clj:5908)\n\tat clojure.core$load_one.invoke(core.clj:5903)\n\tat clojure.core$load_lib$fn__6765.invoke(core.clj:5948)\n\tat clojure.core$load_lib.invokeStatic(core.clj:5947)\n\tat clojure.core$load_lib.doInvoke(core.clj:5928)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$load_libs.invokeStatic(core.clj:5985)\n\tat clojure.core$load_libs.doInvoke(core.clj:5969)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$require.invokeStatic(core.clj:6007)\n\tat clojure.core$require.doInvoke(core.clj:6007)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.core$apply.invokeStatic(core.clj:667)\n\tat clojure.core$apply.invoke(core.clj:660)\n\tat user$eval224.invokeStatic(form-init9216958596789705193.clj:1)\n\tat user$eval224.invoke(form-init9216958596789705193.clj:1)\n\tat clojure.lang.Compiler.eval(Compiler.java:7176)\n\tat clojure.lang.Compiler.eval(Compiler.java:7166)\n\tat clojure.lang.Compiler.load(Compiler.java:7635)\n\tat clojure.lang.Compiler.loadFile(Compiler.java:7573)\n\tat clojure.main$load_script.invokeStatic(main.clj:452)\n\tat clojure.main$init_opt.invokeStatic(main.clj:454)\n\tat clojure.main$init_opt.invoke(main.clj:454)\n\tat clojure.main$initialize.invokeStatic(main.clj:485)\n\tat clojure.main$null_opt.invokeStatic(main.clj:519)\n\tat clojure.main$null_opt.invoke(main.clj:516)\n\tat clojure.main$main.invokeStatic(main.clj:598)\n\tat clojure.main$main.doInvoke(main.clj:561)\n\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\n\tat clojure.lang.Var.applyTo(Var.java:705)\n\tat clojure.main.main(main.java:37)\nCaused by: java.lang.ClassNotFoundException: clojure.string\n\tat java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:476)\n\tat clojure.lang.DynamicClassLoader.findClass(DynamicClassLoader.java:69)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:594)\n\tat clojure.lang.DynamicClassLoader.loadClass(DynamicClassLoader.java:77)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:527)\n\tat java.base/java.lang.Class.forName0(Native Method)\n\tat java.base/java.lang.Class.forName(Class.java:398)\n\tat clojure.lang.RT.classForName(RT.java:2207)\n\tat clojure.lang.RT.classForName(RT.java:2216)\n\tat clojure.lang.Compiler.resolveIn(Compiler.java:7394)\n\tat clojure.lang.Compiler.resolve(Compiler.java:7357)\n\tat clojure.lang.Compiler.analyzeSymbol(Compiler.java:7318)\n\tat clojure.lang.Compiler.analyze(Compiler.java:6768)\n\t... 84 more\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "wordy", "response": "Unable to analyze test case\nreason: too many tokens to analyze", "reason": "too many tokens to analyze", "tokens": 5875, "instructions": "instructions.md\n# Instructions\n\nParse and evaluate simple math word problems returning the answer as an integer.\n\n## Iteration 0 \u2014 Numbers\n\nProblems with no operations simply evaluate to the number given.\n\n> What is 5?\n\nEvaluates to 5.\n\n## Iteration 1 \u2014 Addition\n\nAdd two numbers together.\n\n> What is 5 plus 13?\n\nEvaluates to 18.\n\nHandle large numbers and negative numbers.\n\n## Iteration 2 \u2014 Subtraction, Multiplication and Division\n\nNow, perform the other three operations.\n\n> What is 7 minus 5?\n\n2\n\n> What is 6 multiplied by 4?\n\n24\n\n> What is 25 divided by 5?\n\n5\n\n## Iteration 3 \u2014 Multiple Operations\n\nHandle a set of operations, in sequence.\n\nSince these are verbal word problems, evaluate the expression from\nleft-to-right, _ignoring the typical order of operations._\n\n> What is 5 plus 13 plus 6?\n\n24\n\n> What is 3 plus 2 multiplied by 3?\n\n15  (i.e. not 9)\n\n## Iteration 4 \u2014 Errors\n\nThe parser should reject:\n\n* Unsupported operations (\"What is 52 cubed?\")\n* Non-math questions (\"Who is the President of the United States\")\n* Word problems with invalid syntax (\"What is 1 plus plus 2?\")\n\n## Bonus \u2014 Exponentials\n\nIf you'd like, handle exponentials.\n\n> What is 2 raised to the 5th power?\n\n32\n\n", "code": "wordy.clj\n(ns wordy)\n(defn tokenize [input]\n  (clojure.string/split input #\"\\s+\"))\n\n(defn parse [tokens]\n  (loop [tokens tokens\n         operations []]\n    (if (empty? tokens)\n      operations\n      (let [token (first tokens)]\n        (cond\n          (re-matches #\"^-?\\d+$\" token)\n          (recur (rest tokens) (conj operations (Integer/parseInt token)))\n\n          (= token \"plus\")\n          (recur (rest tokens) (conj operations +))\n\n          (= token \"minus\")\n          (recur (rest tokens) (conj operations -))\n\n          (= token \"multiplied\")\n          (recur (rest (rest tokens)) (conj operations *))\n\n          (= token \"divided\")\n          (recur (rest (rest tokens)) (conj operations /))\n\n          :else\n          (recur (rest tokens) operations))))))\n\n(defn evaluate\n  ([]\n   (evaluate \"\"))\n  ([input]\n   (if (clojure.string/blank? input)\n     nil\n     (let [tokens (tokenize input)\n           operations (parse tokens)]\n       (loop [ops operations\n              result 0]\n         (if (empty? ops)\n           result\n           (let [op (first ops)]\n             (if (fn? op)\n               (recur (rest ops) (op result (first (rest ops))))\n               (recur (rest ops) op)))))))))\n(defn evaluate [] ;; <- arglist goes here\n      ;; your code goes here\n)\n", "test-output": "test_output.txt\n\nlein test wordy-test\n\nlein test :only wordy-test/addition-with-negative-numbers\n\nERROR in (addition-with-negative-numbers) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is -1 plus -10?\") -11)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__454.invokeStatic (wordy_test.clj:12)\n    wordy_test/fn (wordy_test.clj:11)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/subtraction-then-addition\n\nERROR in (subtraction-then-addition) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 17 minus 6 plus 3?\") 14)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__494.invokeStatic (wordy_test.clj:36)\n    wordy_test/fn (wordy_test.clj:35)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/addition-and-multiplication\n\nERROR in (addition-and-multiplication) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is -3 plus 7 multiplied by -2?\") -8)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__504.invokeStatic (wordy_test.clj:42)\n    wordy_test/fn (wordy_test.clj:41)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/subtraction\n\nERROR in (subtraction) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 4 minus -12?\") 16)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__464.invokeStatic (wordy_test.clj:18)\n    wordy_test/fn (wordy_test.clj:17)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/division\n\nERROR in (division) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 33 divided by -3?\") -11)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__474.invokeStatic (wordy_test.clj:24)\n    wordy_test/fn (wordy_test.clj:23)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/multiple-multiplication\n\nERROR in (multiple-multiplication) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 2 multiplied by -2 multiplied by 3?\") -12)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__499.invokeStatic (wordy_test.clj:39)\n    wordy_test/fn (wordy_test.clj:38)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/addition\n\nERROR in (addition) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 1 plus 1?\") 2)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__444.invokeStatic (wordy_test.clj:6)\n    wordy_test/fn (wordy_test.clj:5)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/large-addition\n\nERROR in (large-addition) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 123 plus 45678?\") 45801)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__459.invokeStatic (wordy_test.clj:15)\n    wordy_test/fn (wordy_test.clj:14)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/multiple-subtraction\n\nERROR in (multiple-subtraction) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 20 minus 4 minus 13?\") 3)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__489.invokeStatic (wordy_test.clj:33)\n    wordy_test/fn (wordy_test.clj:32)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/multiple-division\n\nERROR in (multiple-division) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is -12 divided by 2 divided by -3?\") 2)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__509.invokeStatic (wordy_test.clj:45)\n    wordy_test/fn (wordy_test.clj:44)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/more-addition\n\nERROR in (more-addition) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 53 plus 2?\") 55)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__449.invokeStatic (wordy_test.clj:9)\n    wordy_test/fn (wordy_test.clj:8)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/multiple-additions\n\nERROR in (multiple-additions) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 1 plus 1 plus 1?\") 3)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__479.invokeStatic (wordy_test.clj:27)\n    wordy_test/fn (wordy_test.clj:26)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/multiplication\n\nERROR in (multiplication) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is -3 multiplied by 25?\") -75)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__469.invokeStatic (wordy_test.clj:21)\n    wordy_test/fn (wordy_test.clj:20)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nlein test :only wordy-test/addition-and-subtraction\n\nERROR in (addition-and-subtraction) (AFn.java:429)\nexpected: (= (wordy/evaluate \"What is 1 plus 5 minus -2?\") 8)\n  actual: clojure.lang.ArityException: Wrong number of args (1) passed to: wordy/evaluate\n at clojure.lang.AFn.throwArity (AFn.java:429)\n    clojure.lang.AFn.invoke (AFn.java:32)\n    wordy_test$fn__484.invokeStatic (wordy_test.clj:30)\n    wordy_test/fn (wordy_test.clj:29)\n    clojure.test$test_var$fn__9707.invoke (test.clj:717)\n    clojure.test$test_var.invokeStatic (test.clj:717)\n    clojure.test$test_var.invoke (test.clj:708)\n    clojure.test$test_vars$fn__9733$fn__9738.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars$fn__9733.invoke (test.clj:735)\n    clojure.test$default_fixture.invokeStatic (test.clj:687)\n    clojure.test$default_fixture.invoke (test.clj:683)\n    clojure.test$test_vars.invokeStatic (test.clj:731)\n    clojure.test$test_all_vars.invokeStatic (test.clj:737)\n    clojure.test$test_ns.invokeStatic (test.clj:758)\n    clojure.test$test_ns.invoke (test.clj:743)\n    user$eval224$fn__345.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.AFn.applyToHelper (AFn.java:156)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$compose_hooks$fn__154.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    leiningen.core.injected$run_hooks.invokeStatic (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$run_hooks.invoke (form-init3175609222997845561.clj:1)\n    leiningen.core.injected$prepare_for_hooks$fn__159$fn__160.doInvoke (form-init3175609222997845561.clj:1)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.AFunction$1.doInvoke (AFunction.java:31)\n    clojure.lang.RestFn.invoke (RestFn.java:408)\n    clojure.core$map$fn__5851.invoke (core.clj:2755)\n    clojure.lang.LazySeq.sval (LazySeq.java:42)\n    clojure.lang.LazySeq.seq (LazySeq.java:51)\n    clojure.lang.Cons.next (Cons.java:39)\n    clojure.lang.RT.boundedLength (RT.java:1788)\n    clojure.lang.RestFn.applyTo (RestFn.java:130)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.test$run_tests.invokeStatic (test.clj:768)\n    clojure.test$run_tests.doInvoke (test.clj:768)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:665)\n    clojure.core$apply.invoke (core.clj:660)\n    user$eval224$fn__357$fn__410.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357$fn__358.invoke (form-init3175609222997845561.clj:1)\n    user$eval224$fn__357.invoke (form-init3175609222997845561.clj:1)\n    user$eval224.invokeStatic (form-init3175609222997845561.clj:1)\n    user$eval224.invoke (form-init3175609222997845561.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:7176)\n    clojure.lang.Compiler.eval (Compiler.java:7166)\n    clojure.lang.Compiler.load (Compiler.java:7635)\n    clojure.lang.Compiler.loadFile (Compiler.java:7573)\n    clojure.main$load_script.invokeStatic (main.clj:452)\n    clojure.main$init_opt.invokeStatic (main.clj:454)\n    clojure.main$init_opt.invoke (main.clj:454)\n    clojure.main$initialize.invokeStatic (main.clj:485)\n    clojure.main$null_opt.invokeStatic (main.clj:519)\n    clojure.main$null_opt.invoke (main.clj:516)\n    clojure.main$main.invokeStatic (main.clj:598)\n    clojure.main$main.doInvoke (main.clj:561)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.lang.Var.applyTo (Var.java:705)\n    clojure.main.main (main.java:37)\n\nRan 16 tests containing 16 assertions.\n0 failures, 14 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "yacht", "response": "The coder failed the test because the logic in the \"full-house\" and \"four-of-a-kind\" functions is incorrect. The test cases for \"full-house\", \"four-of-a-kind\", \"little-straight\", and \"big-straight\" did not pass, returning 0 instead of the expected scores.\n\nreason: logic\n", "reason": "logic", "tokens": 6514, "instructions": "instructions.md\n# Description\n\nThe dice game [Yacht][yacht] is from the same family as Poker Dice, Generala and particularly Yahtzee, of which it is a precursor.\nIn the game, five dice are rolled and the result can be entered in any of twelve categories.\nThe score of a throw of the dice depends on category chosen.\n\n## Scores in Yacht\n\n| Category | Score | Description | Example |\n| -------- | ----- | ----------- | ------- |\n| Ones | 1 \u00d7 number of ones | Any combination | 1 1 1 4 5 scores 3 |\n| Twos | 2 \u00d7 number of twos | Any combination | 2 2 3 4 5 scores 4 |\n| Threes | 3 \u00d7 number of threes | Any combination | 3 3 3 3 3 scores 15 |\n| Fours | 4 \u00d7 number of fours | Any combination | 1 2 3 3 5 scores 0 |\n| Fives | 5 \u00d7 number of fives| Any combination | 5 1 5 2 5 scores 15 |\n| Sixes | 6 \u00d7 number of sixes | Any combination | 2 3 4 5 6 scores 6 |\n| Full House | Total of the dice | Three of one number and two of another | 3 3 3 5 5 scores 19 |\n| Four of a Kind | Total of the four dice | At least four dice showing the same face | 4 4 4 4 6 scores 16 |\n| Little Straight |  30 points | 1-2-3-4-5 | 1 2 3 4 5 scores 30 |\n| Big Straight | 30 points | 2-3-4-5-6 | 2 3 4 5 6 scores 30 |\n| Choice | Sum of the dice | Any combination | 2 3 3 4 6 scores 18 |\n| Yacht | 50 points | All five dice showing the same face | 4 4 4 4 4 scores 50 |\n\nIf the dice do not satisfy the requirements of a category, the score is zero.\nIf, for example, *Four Of A Kind* is entered in the *Yacht* category, zero points are scored.\nA *Yacht* scores zero if entered in the *Full House* category.\n\n## Task\n\nGiven a list of values for five dice and a category, your solution should return the score of the dice for that category.\nIf the dice do not satisfy the requirements of the category your solution should return 0.\nYou can assume that five values will always be presented, and the value of each will be between one and six inclusively.\nYou should not assume that the dice are ordered.\n\n[yacht]: https://en.wikipedia.org/wiki/Yacht_(dice_game)\n\n", "code": "yacht.clj\n(ns yacht)\n\n(defn count-dice [dice face]\n  (count (filter #(= % face) dice)))\n\n(defn full-house [dice]\n  (let [counts (map #(count-dice dice %) (distinct dice))]\n    (if (and (= 2 (count (distinct counts))) (some #(= % 3) counts))\n      (apply + dice)\n      0)))\n\n(defn four-of-a-kind [dice]\n  (let [counts (map #(count-dice dice %) (distinct dice))]\n    (if (some #(>= % 4) counts)\n      (* 4 (first (filter #(>= (count-dice dice %) 4) (distinct dice))))\n      0)))\n\n(defn little-straight [dice]\n  (if (= (set dice) #{1 2 3 4 5})\n    30\n    0))\n\n(defn big-straight [dice]\n  (if (= (set dice) #{2 3 4 5 6})\n    30\n    0))\n\n(defn choice [dice]\n  (apply + dice))\n\n(defn yacht [dice]\n  (if (= 1 (count (distinct dice)))\n    50\n    0))\n(defn score [dice category]\n  (case category\n    \"ones\" (* 1 (count-dice dice 1))\n    \"twos\" (* 2 (count-dice dice 2))\n    \"threes\" (* 3 (count-dice dice 3))\n    \"fours\" (* 4 (count-dice dice 4))\n    \"fives\" (* 5 (count-dice dice 5))\n    \"sixes\" (* 6 (count-dice dice 6))\n    \"full-house\" (full-house dice)\n    \"four-of-a-kind\" (four-of-a-kind dice)\n    \"little-straight\" (little-straight dice)\n    \"big-straight\" (big-straight dice)\n    \"choice\" (choice dice)\n    \"yacht\" (yacht dice)\n    0))\n", "test-output": "test_output.txt\n\nlein test yacht-test\n\nlein test :only yacht-test/score-test\n\nFAIL in (score-test) (yacht_test.clj:29)\nFull house two small, three big\nexpected: (= 16 (yacht/score [2 2 4 4 4] \"full house\"))\n  actual: (not (= 16 0))\n\nlein test :only yacht-test/score-test\n\nFAIL in (score-test) (yacht_test.clj:31)\nFull house three small, two big\nexpected: (= 19 (yacht/score [5 3 3 5 3] \"full house\"))\n  actual: (not (= 19 0))\n\nlein test :only yacht-test/score-test\n\nFAIL in (score-test) (yacht_test.clj:39)\nFour of a Kind\nexpected: (= 24 (yacht/score [6 6 4 6 6] \"four of a kind\"))\n  actual: (not (= 24 0))\n\nlein test :only yacht-test/score-test\n\nFAIL in (score-test) (yacht_test.clj:41)\nYacht can be scored as Four of a Kind\nexpected: (= 12 (yacht/score [3 3 3 3 3] \"four of a kind\"))\n  actual: (not (= 12 0))\n\nlein test :only yacht-test/score-test\n\nFAIL in (score-test) (yacht_test.clj:45)\nLittle Straight\nexpected: (= 30 (yacht/score [3 5 4 1 2] \"little straight\"))\n  actual: (not (= 30 0))\n\nlein test :only yacht-test/score-test\n\nFAIL in (score-test) (yacht_test.clj:55)\nBig Straight\nexpected: (= 30 (yacht/score [4 6 2 5 3] \"big straight\"))\n  actual: (not (= 30 0))\n\nRan 1 tests containing 29 assertions.\n6 failures, 0 errors.\nTests failed.\n"},{"iterations": 2, "passed": false, "test": "zipper", "response": "The coder failed the test because the 'up' function does not work as expected, causing the focus to not move correctly within the data structure. As a result, multiple test cases failed due to incorrect focus movement and values being returned.\n\nreason: logic\n", "reason": "logic", "tokens": 6654, "instructions": "instructions.md\n# Description\n\nCreating a zipper for a binary tree.\n\n[Zippers][zipper] are a purely functional way of navigating within a data structure and manipulating it.\nThey essentially contain a data structure and a pointer into that data structure (called the focus).\n\nFor example given a rose tree (where each node contains a value and a list of child nodes) a zipper might support these operations:\n\n- `from_tree` (get a zipper out of a rose tree, the focus is on the root node)\n- `to_tree` (get the rose tree out of the zipper)\n- `value` (get the value of the focus node)\n- `prev` (move the focus to the previous child of the same parent,\n  returns a new zipper)\n- `next` (move the focus to the next child of the same parent, returns a\n  new zipper)\n- `up` (move the focus to the parent, returns a new zipper)\n- `set_value` (set the value of the focus node, returns a new zipper)\n- `insert_before` (insert a new subtree before the focus node, it\n  becomes the `prev` of the focus node, returns a new zipper)\n- `insert_after` (insert a new subtree after the focus node, it becomes\n  the `next` of the focus node, returns a new zipper)\n- `delete` (removes the focus node and all subtrees, focus moves to the\n  `next` node if possible otherwise to the `prev` node if possible,\n  otherwise to the parent node, returns a new zipper)\n\n[zipper]: https://en.wikipedia.org/wiki/Zipper_%28data_structure%29\n\n", "code": "zipper.clj\n(ns zipper)\n\n(defn from-tree [tree]\n  {:tree tree :path []})\n\n(defn value [zipper]\n  (:value (:tree zipper)))\n\n(defn left [zipper]\n  (let [left-child (:left (:tree zipper))]\n    (if left-child\n      (assoc zipper :tree left-child :path (conj (:path zipper) :left)))))\n\n(defn right [zipper]\n  (let [right-child (:right (:tree zipper))]\n    (if right-child\n      (assoc zipper :tree right-child :path (conj (:path zipper) :right)))))\n\n(defn to-tree [zipper]\n  (:tree zipper))\n\n(defn up [zipper]\n  (let [path (:path zipper)]\n    (if (empty? path)\n      nil\n      (assoc zipper :tree (get-in (:tree zipper) (reverse (conj (pop path) :tree))) :path (pop path)))))\n\n(defn set-value [zipper value]\n  (assoc-in zipper [:tree :value] value))\n\n(defn set-left [zipper left]\n  (assoc-in zipper [:tree :left] left))\n\n(defn set-right [zipper right]\n  (assoc-in zipper [:tree :right] right))\n", "test-output": "test_output.txt\n\nlein test zipper-test\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:32)\ntree from deep focus\nexpected: (= tree (-> tree zipper/from-tree zipper/left zipper/right zipper/to-tree))\n  actual: (not (= {:value 1, :left {:value 2, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} {:value 3, :left nil, :right nil}))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:43)\nleft, right, and up\nexpected: (= 3 (-> tree zipper/from-tree zipper/left zipper/up zipper/right zipper/up zipper/left zipper/right zipper/value))\n  actual: (not (= 3 nil))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:54)\ntest ability to descend multiple levels and return\nexpected: (= 1 (-> tree zipper/from-tree zipper/left zipper/right zipper/up zipper/up zipper/value))\n  actual: (not (= 1 nil))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:63)\nset_value\nexpected: (= {:value 1, :left {:value 5, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} (-> tree zipper/from-tree zipper/left (zipper/set-value 5) zipper/to-tree))\n  actual: (not (= {:value 1, :left {:value 5, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} {:value 5, :left nil, :right {:value 3, :left nil, :right nil}}))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:78)\nset_value after traversing up\nexpected: (= {:value 1, :left {:value 5, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} (-> tree zipper/from-tree zipper/left zipper/right zipper/up (zipper/set-value 5) zipper/to-tree))\n  actual: (not (= {:value 1, :left {:value 5, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} {:value 5}))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:95)\nset_left with leaf\nexpected: (= {:value 1, :left {:value 2, :left {:value 5, :left nil, :right nil}, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} (-> tree zipper/from-tree zipper/left (zipper/set-left {:value 5, :left nil, :right nil}) zipper/to-tree))\n  actual: (not (= {:value 1, :left {:value 2, :left {:value 5, :left nil, :right nil}, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} {:value 2, :left {:value 5, :left nil, :right nil}, :right {:value 3, :left nil, :right nil}}))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:114)\nset_right with null\nexpected: (= {:value 1, :left {:value 2, :left nil, :right nil}, :right {:value 4, :left nil, :right nil}} (-> tree zipper/from-tree zipper/left (zipper/set-right nil) zipper/to-tree))\n  actual: (not (= {:value 1, :left {:value 2, :left nil, :right nil}, :right {:value 4, :left nil, :right nil}} {:value 2, :left nil, :right nil}))\n\nlein test :only zipper-test/expected-value-test\n\nFAIL in (expected-value-test) (zipper_test.clj:151)\nset_value on deep focus\nexpected: (= {:value 1, :left {:value 2, :left nil, :right {:value 5, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} (-> tree zipper/from-tree zipper/left zipper/right (zipper/set-value 5) zipper/to-tree))\n  actual: (not (= {:value 1, :left {:value 2, :left nil, :right {:value 5, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} {:value 5, :left nil, :right nil}))\n\nlein test :only zipper-test/sameResultFromOperations-test\n\nFAIL in (sameResultFromOperations-test) (zipper_test.clj:169)\ndifferent paths to same zipper\nexpected: (= (-> {:value 1, :left {:value 2, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} zipper/from-tree zipper/right) (-> {:value 1, :left {:value 2, :left nil, :right {:value 3, :left nil, :right nil}}, :right {:value 4, :left nil, :right nil}} zipper/from-tree zipper/left zipper/up zipper/right))\n  actual: (not (= {:tree {:value 4, :left nil, :right nil}, :path [:right]} nil))\n\nRan 2 tests containing 14 assertions.\n9 failures, 0 errors.\nTests failed.\n"}]
        const selector = document.getElementById("selector")
        var results_map = {}
        var passed = 0
        var passedIterations = {}
        var failed = 0
        var reasons = {}
        var tokens = 0
        var totalIterations = 0

        for(result of results) {
            const button = document.createElement("button")
            const test = result.test
            button.innerHTML = test
            button.onclick = (event) => {
                window.location.hash = test
            }
            selector.appendChild(button)

            results_map[test] = result
            if(result["passed"]) {
                button.className = "success"
                passed += 1
                if(!(result["iterations"] in passedIterations)) {
                    passedIterations[result["iterations"]] = 0
                }
                passedIterations[result["iterations"]] += 1
                tokens += result["tokens"]
                totalIterations += result["iterations"]
            } else {
                button.className = "failure"
                failed += 1
                if(!(result["reason"] in reasons)) {
                    reasons[result["reason"]] = 0
                }
                reasons[result["reason"]] += 1
            }
        }

        var avgTokens = Math.floor(tokens / totalIterations)
        document.getElementById("tokens").innerHTML = `Average tokens per iteration for passed tests: ${avgTokens}`
        var passedString = ""
        for(iterations in passedIterations) {
            if(iterations == 1) {
                plural = ""
            } else {
                plural = "s"
            }
            passedString += `${iterations} iteration${plural}: ${passedIterations[iterations]}, `
        }
        passedString += `Total: ${passed}`
        document.getElementById("passed").innerHTML = passedString
        document.getElementById("failed").innerHTML = `Failed: ${failed}`
        var reasonsString = "Reasons: "
        for(reason in reasons) {
            reasonsString += `${reason}: ${reasons[reason]} `
        }
        document.getElementById("reasons").innerHTML = reasonsString
        
        addEventListener("hashchange", (event) => {
            const viewer = document.getElementById("viewer")
            viewer.replaceChildren()
            const test = window.location.hash.substring(1)
            if(!(test in results_map)) {
                return
            }

            const result = results_map[test]
            const instructions = document.createElement("div")
            const code = document.createElement("div")
            const analysis = document.createElement("div")
            const output = document.createElement("div")

            instructions.innerHTML = "<h1>Instructions:</h1>" + result["instructions"]
            code.innerHTML = "<h1>Code:</h1>" + result["code"]
            if("response" in result) {
                response = result["response"]
            } else {
                if(result["iterations"] == 1) {
                    plural = ""
                } else {
                    plural = "s"
                }
                response = `Passed in ${result["iterations"]} iteration${plural}\nConsumed ${result["tokens"]} tokens, or ${result["tokens"] / result["iterations"]} tokens per iteration`
            }
            analysis.innerHTML = "<h1>Analysis:</h1>" + response
            output.innerHTML = "<h1>Test Output:</h1>" + result["test-output"]

            instructions.className = "content"
            code.className = "content"
            analysis.className = "content"
            output.className = "content"

            viewer.appendChild(analysis)
            viewer.appendChild(code)
            viewer.appendChild(output)
            viewer.appendChild(instructions)
        });
    </script>
    <style>
        html {
            height: 100%;
        }

        body {
            height: 100%; 
            padding: 0; 
            margin: 0;
            display: flex;
            flex-direction: column;
        }

        #header {
            display: flex;
            flex-direction: row;
            font-size: 18px;
            margin: 0;
        }

        #container {
            display: flex; 
            flex-direction: row;
            flex-grow: 1;
            min-height: 0;
        }

        #selector {
            display: flex;
            flex-shrink: 0;
            flex-direction: column;
            border: 1px solid black; 
            padding: 8px; gap: 8px;
            overflow-y: scroll;
        }

        #viewer {
            display: flex;
            flex-direction: column;
            background-color: rgb(233, 250, 255);
            flex-grow: 1; 
            border: 1px solid black;
            font-size: 20px;
            min-width: 0;
        }

        button {
            font-size: 18px;
            padding: 6px;
            margin: 6px;
        }

        .content {
            border: 1px solid black;
            padding: 8px;
            white-space: pre;
            overflow-y: scroll;
            min-height: 200px;
        }

        h1 {
            margin: 2px;
        }

        p {
            margin: 0px;
            padding: 14px;
            border-right: 1px solid black;

        }

        .success {
            background-color: rgb(205, 255, 205);
        }

        .failure {
            background-color: rgb(255, 184, 184);
        }
    </style>
</html>
